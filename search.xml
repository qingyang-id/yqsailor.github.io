<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 搭建 Shadowsocks VPN服务]]></title>
    <url>%2F2019%2F06%2F18%2Fshadowsocks%2F</url>
    <content type="text"><![CDATA[前言公司的VPN被封了，因此就注册了AWS，搭建自己的shadowsocks代理服务器，实现科学上网。AWS为新用户提供了一年每月750小时和30G流量的1核1G服务器，当然也可以选择google云，也为新用户提供了一年的免费试用。 安装PIPDebian/Ubuntu下使用本教程使用Python 3为载体，因Python 3对应的包管理器pip3并未预装，首先安装pip3： Ubuntu16 安装pip 1sudo apt install python3-pip Ubuntu18 安装pip 123sudo apt-get updatesudo apt-get install python3-pip Centos下使用12sudo yum install -y epel-releasesudo yum install python3-pip 安装Shadowsocks因Shadowsocks作者不再维护pip中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks： 1sudo pip3 install --upgrade git+https://github.com/shadowsocks/shadowsocks.git@master 安装完成后可以使用下面这个命令查看Shadowsocks版本： 1sudo ssserver --version 目前会显示“Shadowsocks 3.0.0”。 创建配置文件创建Shadowsocks配置文件所在文件夹： 1sudo mkdir /etc/shadowsocks 然后创建配置文件： 1sudo vi /etc/shadowsocks/config.json 复制粘贴如下内容（注意修改密码“password”）： 12345678910&#123; "server":"0.0.0.0", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"123456", "timeout":300, "method":"chacha20", "fast_open": false&#125; “server” ；服务器IP，不用更改“server_port” ；服务器端口，即用于给用户连接的端口，范围0-65535，任选一个端口，只要不与常用端口冲突就行，不过不推荐使用80\443等网站用端口，也不推荐大多数ss的默认端口8388“local_address” ；本机地址，不用更改“local_port” ；本地端端口，不用更改“password” ；账户的密码“timeout” ；超时时间（秒），不用改“method” ；加密方式，推荐用 chacha20 ，不用默认的 rc4-md5 或者 aes-256-cfb，因为默认的太多人用，容易被墙“fast_open” ；true 或 false。如果服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可多个账号： 1234567891011121314&#123; "server":"0.0.0.0", "port_password":&#123; "8381":"xxx", // xxx为端口对应的密码 "8382":"xxx", "8383":"xxx", "8384":"xxx" &#125;, "local_address": "127.0.0.1", "local_port":1080, "timeout":300, "method":"chacha20", "fast_open": false &#125; 测试Shadowsocks配置启动shadowsocks 1ssserver -c /etc/shadowsocks/config.json 在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址为服务器外网IP，端口号为8388，加密方法为chacha20，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。 这时浏览器访问ip138就会显示Shadowsocks服务器的IP啦！ 测试完毕，按Ctrl + C关闭Shadowsocks。 如果无法使用，可能是端口未开放，防火墙需开放8388端口 配置Systemd管理Shadowsocks新建Shadowsocks管理文件 1sudo vim /etc/systemd/system/shadowsocks-server.service 复制粘贴： 12345678910[Unit]Description=Shadowsocks ServerAfter=network.target[Service]ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.jsonRestart=on-abort[Install]WantedBy=multi-user.target 保存文件并退出。 启动Shadowsocks： 1sudo systemctl start shadowsocks-server 设置开机启动Shadowsocks： 1sudo systemctl enable shadowsocks-server 查看Shadowsocks状态： 1sudo systemctl status shadowsocks-server 至此，Shadowsock服务器端的基本配置已经全部完成了！ 优化这部分属于进阶操作，在你使用Shadowsocks时感觉到延迟较大，或吞吐量较低时，可以考虑对服务器端进行优化。 开启BBRBBR系Google最新开发的TCP拥塞控制算法，目前有着较好的带宽提升效果，甚至不比老牌的锐速差。 升级Linux内核BBR在Linux kernel 4.9引入。首先检查服务器kernel版本： 1uname -r 如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文。 更新包管理器： 1sudo apt update 查看可用的Linux内核版本： 1sudo apt-cache showpkg linux-image 找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”： 1sudo apt install linux-image-4.10.0-22-generic 等待安装完成后重启服务器： 1sudo reboot 删除老的Linux内核： 1sudo purge-old-kernels 开启BBR运行lsmod | grep bbr，如果结果中没有tcp_bbr，则先运行： 12modprobe tcp_bbrecho "tcp_bbr" &gt;&gt; /etc/modules-load.d/modules.conf 运行： 12echo "net.core.default_qdisc=fq" &gt;&gt; /etc/sysctl.confecho "net.ipv4.tcp_congestion_control=bbr" &gt;&gt; /etc/sysctl.conf 运行： 1sysctl -p 保存生效。运行： 12sysctl net.ipv4.tcp_available_congestion_controlsysctl net.ipv4.tcp_congestion_control 若均有bbr，则开启BBR成功。 优化吞吐量新建配置文件： 1sudo nano /etc/sysctl.d/local.conf 复制粘贴： 1234567891011121314151617181920212223242526272829303132333435363738394041# max open filesfs.file-max = 51200# max read buffernet.core.rmem_max = 67108864# max write buffernet.core.wmem_max = 67108864# default read buffernet.core.rmem_default = 65536# default write buffernet.core.wmem_default = 65536# max processor input queuenet.core.netdev_max_backlog = 4096# max backlognet.core.somaxconn = 4096# resist SYN flood attacksnet.ipv4.tcp_syncookies = 1# reuse timewait sockets when safenet.ipv4.tcp_tw_reuse = 1# turn off fast timewait sockets recyclingnet.ipv4.tcp_tw_recycle = 0# short FIN timeoutnet.ipv4.tcp_fin_timeout = 30# short keepalive timenet.ipv4.tcp_keepalive_time = 1200# outbound port rangenet.ipv4.ip_local_port_range = 10000 65000# max SYN backlognet.ipv4.tcp_max_syn_backlog = 4096# max timewait sockets held by system simultaneouslynet.ipv4.tcp_max_tw_buckets = 5000# turn on TCP Fast Open on both client and server sidenet.ipv4.tcp_fastopen = 3# TCP receive buffernet.ipv4.tcp_rmem = 4096 87380 67108864# TCP write buffernet.ipv4.tcp_wmem = 4096 65536 67108864# turn on path MTU discoverynet.ipv4.tcp_mtu_probing = 1net.ipv4.tcp_congestion_control = bbr 运行： 1sysctl --system 编辑之前的shadowsocks-server.service文件： 1sudo nano /etc/systemd/system/shadowsocks-server.service 在ExecStart前插入一行，内容为： 1ExecStartPre=/bin/sh -c 'ulimit -n 51200' 即修改后的shadowsocks-server.service内容为： 1234567891011[Unit]Description=Shadowsocks ServerAfter=network.target[Service]ExecStartPre=/bin/sh -c 'ulimit -n 51200'ExecStart=/usr/local/bin/ssserver -c /etc/shadowsocks/config.jsonRestart=on-abort[Install]WantedBy=multi-user.target Ctrl + O保存文件，Ctrl + X退出。 重载shadowsocks-server.service： 1sudo systemctl daemon-reload 重启Shadowsocks： 1sudo systemctl restart shadowsocks-server 开启TCP Fast OpenTCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。 编辑config.json： 1sudo nano /etc/shadowsocks/config.json 将fast_open的值由false修改为true。Ctrl + O保存文件，Ctrl + X退出。 重启Shadowsocks： 1sudo systemctl restart shadowsocks-server 注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。 至此，Shadowsock服务器端的优化已经全部完成了！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Shadowsocks</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 搭建 Nginx]]></title>
    <url>%2F2019%2F06%2F17%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx 读作 engine x， 是一个免费的、开源的、高性能的 HTTP 和反向代理服务，主要负责负载一些访问量比较大的站点。 Nginx 可以作为一个独立的 Web 服务，也可以用来给 Apache 或是其他的 Web 服务做反向代理。 相比于 Apache，Nginx 可以处理更多的并发连接，而且每个连接的内存占用的非常小。 本教程将会教您如何在 Centos 7 的服务器上安装和管理 Nginx。 开始前的准备在开始阅读此教程之前，请确保你是以拥有sudo权限的用户来登录的服务器，并且服务器中没有 Apache 或是其他服务正在使用 80（HTTP） 和 443（HTTPS） 端口上，防止端口被占用，造成 Nginx 无法正常启动。 在 CentOS 中安装 Nginx请按照下面的步骤，在 CentOS 中安装 Nginx。 EPEL 仓库中有 Nginx 的安装包。如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装： 1sudo yum install epel-release 上面代码的意思是以sudo权限运行安装 epel-release，如果你当前登录的用户不是 root，则会提示你输入密码来运行，输入密码时是看不到输入的内容的，所以不用担心，继续输入就行。然后回车继续运行，后面的命令中如果包含sudo则都表明是刚提到的意思，不再重复解释。 2. 输入以下命令来安装 Nginx： 1sudo yum install nginx 如果这是您第一次从 EPEL 仓库中安装软件，yum 可能会提示您导入 EPEL GPG key： 1234567Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7Importing GPG key 0x352C64E5:Userid : "Fedora EPEL (7) &lt;epel@fedoraproject.org&gt;"Fingerprint: 91e9 7d7c 4a5e 96f1 7f3e 888f 6a2f aea2 352c 64e5Package : epel-release-7-9.noarch (@extras)From : /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7Is this ok [y/N]: 类似于上面的内容，遇到这种情况，输入y，然后 Enter（回车） 即可继续安装。 3. 等到安装完成以后，可以通过以下命令来设置开机启动和运行 Nginx 服务： 设置 Nginx 开机启动： 1sudo systemctl enable nginx 运行以上命令以后，会输出类似以下的内容，表示创建了一个软连接来关联 Nginx，不用担心，并不是报错了，下一步就可以启动 Nginx 了。 1Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service. 启动 Nginx： 1sudo systemctl start nginx 通过运行以下命令，来检查 Nginx 的运行状态： 1sudo systemctl status nginx 然后会输出类型下面的内容 12345678910● nginx.service - The nginx HTTP and reverse proxy server Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled) Active: active (running) since 一 2019-06-17 20:50:57 CST; 7s ago Process: 4857 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS) Process: 4853 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS) Process: 4852 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS) Main PID: 4859 (nginx) CGroup: /system.slice/nginx.service ├─4859 nginx: master process /usr/sbin/nginx └─4860 nginx: worker process 4. 如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口 通过下面的命令来打开这两个端口： 123sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 国内的服务器厂商，安全组也可能会默认屏蔽这两个端口，比如 阿里云 和 腾讯云，如果在 第 5 步 时发现无法访问，可以自行百度一下如何放开这两个端口。 5、 验证 Nginx 是否成功启动，可以在浏览器中打开 http://YOUR_IP，您将看到默认的 Nginx 欢迎页面，类似于下图所示： 注：Nginx 的默认欢迎页有好几种样式，和你安装的版本有关，所以大家只用关注这个页面的大标题就行了 Welcome to nginx！ 通过 systemctl 管理 Nginx你可以像管理其他服务那样管理 Nginx。 启动 Nginx 1sudo systemctl start nginx 停止 Nginx 1sudo systemctl stop nginx 重启 Nginx 1sudo systemctl restart nginx 修改 Nginx 配置后，重新加载 1sudo systemctl reload nginx 设置开机启动 Nginx 1sudo systemctl enable nginx 关闭开机启动 Nginx 1sudo systemctl disable nginx Nginx 的配置文件和最佳实践1、通过以上方式安装的 Nginx，所有相关的配置文件都在 /etc/nginx/ 目录中。 2、Nginx 的主配置文件是 /etc/nginx/nginx.conf。 3、为了使 Nginx 配置更易于维护，建议为每个服务（域名）创建一个单独的配置文件。 4、每一个独立的 Nginx 服务配置文件都必须以 .conf 结尾，并存储在 /etc/nginx/conf.d 目录中。您可以根据需求，创建任意多个独立的配置文件。 5、独立的配置文件，建议遵循以下命名约定，比如你的域名是 kaifazhinan.com，那么你的配置文件的应该是这样的 /etc/nginx/conf.d/kaifazhinan.com.conf，如果你在一个服务器中部署多个服务，当然你也可以在文件名中加上 Nginx 转发的端口号，比如 kaifazhinan.com.3000.conf，这样做看起来会更加友好。 6、如果你的配置中有很多重复的代码，那么建议你创建一个 /etc/nginx/snippets 文件夹，在这里面存放所有会被复用的代码块，然后在各个需要用到的 Nginx 的配置文件中引用进去，这样可以更方便管理和修改。 7、Nginx 日志文件（access.log 和 error.log ）位于 /var/log/nginx/ 目录中。建议为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。 8、你可以将要部署的代码文件，存储在任何你想的位置，但是一般推荐存放在下列位置中的其中一个： 12345/home/&lt;user_name&gt;/&lt;site_name&gt;/var/www/&lt;site_name&gt;/var/www/html/&lt;site_name&gt;/opt/&lt;site_name&gt;/usr/share/nginx/html 总结首先恭喜你，你已经成功的在 CentOS 7 上安装了 Nginx 服务，你现在可以在你的服务器中通过 Nginx 部署你的服务代码啦。 期待下次与你相见 : )]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenZeppelin ERC20源码分析]]></title>
    <url>%2F2018%2F09%2F15%2Ferc20%2F</url>
    <content type="text"><![CDATA[ERC20：Ethereum Request for Comments 20，是一个基于以太坊代币的接口标准（协议）。所有符合 ERC-20 标准的代币都能立即兼容以太坊钱包，它能让用户和交易所，都能非常方便的管理多种代币，转账、存储、ICO 等等。 OpenZeppelin 的 Token 中实现了 ERC20 的一个安全的合约代码，本篇主要来分析一下源码，了解一下 ERC20 的实现，由于代码之间的调用可能略复杂，直接每个文件每个文件的来看会有点绕，我直接画了一个继承和调用关系的思维导图，可以帮助更容易地看源码。 ERC20Basic.sol12345678pragma solidity ^0.4.23;contract ERC20Basic &#123; function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value);&#125; ERC20Basic 合约主要定义了 ERC20 的基本接口，定义了必须要实现的方法: totalSupply 返回总共发行量balanceOf 查询指定 address 的余额transfer 发送指定数目的 token 到指定账户，同时发送后需要触发Transfer事件Transfer事件,任何 token 发送发生时，必须触发该事件，即使是 0 额度。 当一个 token 合约创建时，应该触发一个 Transfer 事件，token 的发送方是 0x0，也就是说凭空而来的 token，简称空气币。 ERC20.sol123456789101112131415161718pragma solidity ^0.4.23;import &quot;./ERC20Basic.sol&quot;;contract ERC20 is ERC20Basic &#123; function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value );&#125; ERC20 合约继承了 ERC20Basic，另外定义了 approve 相关的方法: allowance 获取指定用户的批准额度，控制代币的交易，如可交易账号及资产, 控制 Token 的流通transferFrom 从一个地址向另外一个地址转账指定额度的 token，这个方法可以理解为一个收款流程，允许合约来代表 token 持有者发送代币。比如，合约可以帮助你向另外一个人发送 token 或者索要 token。前提是 token 拥有者必须要通过某些机制对这个请求进行确认，比如通过 MetaMask 进行 confirm。否则，执行将失败。 跟 transfer 一样，即使发送 0 代币，也要触发Transfer事件。approve 批准额度，允许一个账户最多能从你的账户你取现指定额度。重复调用时，以最后一次的额度为主。为了防止攻击，最开始这个额度必须设置为 0。Approval事件，当 approve 被调用时，需要触发该事件。 DetailedERC20.sol123456789101112131415pragma solidity ^0.4.23;import &quot;./ERC20.sol&quot;;contract DetailedERC20 is ERC20 &#123; string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public &#123; name = _name; symbol = _symbol; decimals = _decimals; &#125;&#125; DetailedERC20 主要定义了 token 的展示信息: name token 的名称,比如”XXXToken”symbol token 的符号,比如”XXX”decimals token 精确的小数点位数，比如 18 BasicToken.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051pragma solidity ^0.4.23;import &quot;./ERC20Basic.sol&quot;;import &quot;../../math/SafeMath.sol&quot;;/** * @title 实现ERC20基本合约的接口 * @dev 基本的StandardToken，不包含allowances. */contract BasicToken is ERC20Basic &#123; using SafeMath for uint256; mapping(address =&gt; uint256) balances; uint256 totalSupply_; /** * @dev 返回存在的token总数 */ function totalSupply() public view returns (uint256) &#123; return totalSupply_; &#125; /** * @dev 给特定的address转token * @param _to 要转账到的address * @param _value 要转账的金额 */ function transfer(address _to, uint256 _value) public returns (bool) &#123; //做相关的合法验证 require(_to != address(0)); require(_value &lt;= balances[msg.sender]); // msg.sender余额中减去额度，_to余额加上相应额度 balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); //触发Transfer事件 emit Transfer(msg.sender, _to, _value); return true; &#125; /** * @dev 获取指定address的余额 * @param _owner 查询余额的address. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) &#123; return balances[_owner]; &#125;&#125; 通过SafeMath来做运算很重要，在我们自己写合约的时候也尽量使用，可以避免一些计算过程的溢出等安全问题。 StandardToken.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132pragma solidity ^0.4.23;import &quot;./BasicToken.sol&quot;;import &quot;./ERC20.sol&quot;;/** * @title 标准 ERC20 token * * @dev 实现基础的标准token * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */contract StandardToken is ERC20, BasicToken &#123; mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed; /** * @dev 从一个地址向另外一个地址转token * @param _from 转账的from地址 * @param _to address 转账的to地址 * @param _value uint256 转账token数量 */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) &#123; // 做合法性检查 require(_to != address(0)); require(_value &lt;= balances[_from]); require(_value &lt;= allowed[_from][msg.sender]); //_from余额减去相应的金额 //_to余额加上相应的金额 //msg.sender可以从账户_from中转出的数量减少_value balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); // 触发Transfer事件 emit Transfer(_from, _to, _value); return true; &#125; /** * @dev 批准传递的address以代表msg.sender花费指定数量的token * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender&apos;s allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender 花费资金的地址 * @param _value 可以被花费的token数量 */ function approve(address _spender, uint256 _value) public returns (bool) &#123; //记录msg.sender允许_spender动用的token allowed[msg.sender][_spender] = _value; //触发Approval事件 emit Approval(msg.sender, _spender, _value); return true; &#125; /** * @dev 函数检查所有者允许的_spender花费的token数量 * @param _owner address 资金所有者地址. * @param _spender address 花费资金的spender的地址. * @return A uint256 指定_spender仍可用token的数量。 */ function allowance( address _owner, address _spender ) public view returns (uint256) &#123; //允许_spender从_owner中转出的token数 return allowed[_owner][_spender]; &#125; /** * @dev 增加所有者允许_spender花费代币的数量。 * * allowed[_spender] == 0时approve应该被调用. 增加allowed值最好使用此函数避免2此调用（等待知道第一笔交易被挖出） * From MonolithDAO Token.sol * @param _spender 花费资金的地址 * @param _addedValue 用于增加允许动用的token牌数量 */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) &#123; //在之前允许的数量上增加_addedValue allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); //触发Approval事件 emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; &#125; /** * @dev 减少所有者允许_spender花费代币的数量 * * allowed[_spender] == 0时approve应该被调用. 减少allowed值最好使用此函数避免2此调用（等待知道第一笔交易被挖出） * From MonolithDAO Token.sol * @param _spender 花费资金的地址 * @param _subtractedValue 用于减少允许动用的token牌数量 */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) &#123; uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue &gt; oldValue) &#123; //减少的数量少于之前允许的数量，则清零 allowed[msg.sender][_spender] = 0; &#125; else &#123; //减少对应的_subtractedValue数量 allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); &#125; //触发Approval事件 emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; &#125;&#125; 上面合约定义的 mapping allowed，它用来记录某个地址允许另外一个地址动用多少 token。假设钱包地址为 B，有另外一个合约其合约地址为 C，合约 C 会通过支付 XXX Token 来做一些事情，根据 ERC20 的定义，每个地址只能操作属于自己的 Token，则合约 C 无法直接使用 B 地址所拥有的 Token，这时候 allowed Mapping 就派上用场了，它上面可以记录一个允许操作值，像是「B 钱包地址允许 C 合约地址动用属于 B 钱包地址的 1000 XXX Token」，以 Mapping 的结构来说标记为「B =&gt; C =&gt; 1000」 BurnableToken.sol1234567891011121314151617181920212223242526272829pragma solidity ^0.4.23;import &quot;./BasicToken.sol&quot;;/** * @title 可销毁 Token * @dev Token可以被不可逆转地销毁 */contract BurnableToken is BasicToken &#123; event Burn(address indexed burner, uint256 value); /** * @dev 销毁指定数量的token. * @param _value 被销毁的token数量. */ function burn(uint256 _value) public &#123; _burn(msg.sender, _value); &#125; function _burn(address _who, uint256 _value) internal &#123; require(_value &lt;= balances[_who]); //不需要验证value &lt;= totalSupply，因为这意味着发送者的余额大于总供应量，这应该是断言失败 balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); &#125;&#125; 该合约比较简单，就是调用者可以销毁一定数量的 token，然后 totalSupply 减去对应销毁的数量 StandardBurnableToken.sol123456789101112131415161718192021222324pragma solidity ^0.4.23;import &quot;./BurnableToken.sol&quot;;import &quot;./StandardToken.sol&quot;;/** * @title 标准可销毁token * @dev 将burnFrom方法添加到ERC20实现中 */contract StandardBurnableToken is BurnableToken, StandardToken &#123; /** * @dev 从目标地址销毁特定数量的token并减少允许量 * @param _from address token所有者地址 * @param _value uint256 被销毁的token数量 */ function burnFrom(address _from, uint256 _value) public &#123; require(_value &lt;= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // 此方法需要触发具有更新批准的事件。 allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); &#125;&#125; MintableToken.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768pragma solidity ^0.4.23;import &quot;./StandardToken.sol&quot;;import &quot;../../ownership/Ownable.sol&quot;;/** * @title 可增发 token * @dev 简单的可增发的 ERC20 Token 示例 * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */contract MintableToken is StandardToken, Ownable &#123; event Mint(address indexed to, uint256 amount); event MintFinished(); //初始化增发状态为false bool public mintingFinished = false; modifier canMint() &#123; // 检查没有增发结束 require(!mintingFinished); _; &#125; modifier hasMintPermission() &#123; //owner只能为msg.sender require(msg.sender == owner); _; &#125; /** * @dev 增发token方法 * @param _to 获取增发token的地址_to. * @param _amount 增发的token数量. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) &#123; // 总发行量增加_amount数量的token totalSupply_ = totalSupply_.add(_amount); // 获取增发的地址增加_amount数量的token balances[_to] = balances[_to].add(_amount); // 触发增发事件 emit Mint(_to, _amount); // 触发Transfer事件 emit Transfer(address(0), _to, _amount); return true; &#125; /** * @dev 停止增发新token. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) &#123; // 改变增发状态为已完成 mintingFinished = true; // 触发增发已完成事件 emit MintFinished(); return true; &#125;&#125; 增发 token 的合约也很简单，就是通过增发一定量的 token 给对应的 address，并给总发行量增加对应的增发 token，可以通过调用finishMinting来完成增发。 CappedToken.sol12345678910111213141516171819202122232425262728293031323334353637pragma solidity ^0.4.23;import &quot;./MintableToken.sol&quot;;/** * @title 上限 token * @dev 设置一个顶的可增发token. */contract CappedToken is MintableToken &#123; uint256 public cap; constructor(uint256 _cap) public &#123; require(_cap &gt; 0); cap = _cap; &#125; /** * @dev 增发token * @param _to 获取增发token的地址_to. * @param _amount 增发token数量. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public returns (bool) &#123; // 验证总发行量+增发量小于所设置的上限 require(totalSupply_.add(_amount) &lt;= cap); // 调用父合约的增发方法 return super.mint(_to, _amount); &#125;&#125; CappedToken 也很简单，就是在可增发合约上加了一个”cap”，来限制增发的上限 RBACMintableToken.sol1234567891011121314151617181920212223242526272829303132333435363738394041pragma solidity ^0.4.23;import &quot;./MintableToken.sol&quot;;import &quot;../../ownership/rbac/RBAC.sol&quot;;/** * @title RBACMintableToken * @author Vittorio Minacori (@vittominacori) * @dev Mintable Token, with RBAC minter permissions */contract RBACMintableToken is MintableToken, RBAC &#123; /** * 指定一个增发者的常量名. */ string public constant ROLE_MINTER = &quot;minter&quot;; /** * @dev 重写Mintable token合约的 modifier，增加角色有关的逻辑 */ modifier hasMintPermission() &#123; // 调用RBAC合约中的角色检查 checkRole(msg.sender, ROLE_MINTER); _; &#125; /** * @dev 将一个地址添加为可增发者角色 * @param minter address */ function addMinter(address minter) onlyOwner public &#123; addRole(minter, ROLE_MINTER); &#125; /** * @dev 将一个地址移除可增发者角色 * @param minter address */ function removeMinter(address minter) onlyOwner public &#123; removeRole(minter, ROLE_MINTER); &#125;&#125; RBACMintableToken 合约将增发操作中添加了 RBAC 逻辑，就是角色权限管理的逻辑，将一个地址这是为增发者角色，也可以移除一个地址的增发者角色，只有拥有”minter”角色的 address 才有权限增发 token SafeERC20.sol123456789101112131415161718192021222324252627282930pragma solidity ^0.4.23;import &quot;./ERC20Basic.sol&quot;;import &quot;./ERC20.sol&quot;;/** * @title SafeERC20 * @dev 围绕ERC20操作发生故障的包装程序. * 可以在合约中通过这样使用这个库 `using SafeERC20 for ERC20;` 来使用安全的操作`token.safeTransfer(...)` */library SafeERC20 &#123; function safeTransfer(ERC20Basic token, address to, uint256 value) internal &#123; require(token.transfer(to, value)); &#125; function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal &#123; require(token.transferFrom(from, to, value)); &#125; function safeApprove(ERC20 token, address spender, uint256 value) internal &#123; require(token.approve(spender, value)); &#125;&#125; SafeERC20 是一个 ERC20 的安全操作库，在下面的TokenTimelock锁定期后释放 token 的合约中我们可以看到用法 TokenTimelock.sol12345678910111213141516171819202122232425262728293031323334353637383940414243444546pragma solidity ^0.4.23;import &quot;./SafeERC20.sol&quot;;/** * @title TokenTimelock 锁定期释放token * @dev TokenTimelock 是一个令token持有人合同，将允许一个受益人在给定的发布时间之后提取token */contract TokenTimelock &#123; //这里用到了上面的SafeERC20 using SafeERC20 for ERC20Basic; // ERC20 basic token contract being held ERC20Basic public token; // token被释放后的受益人address address public beneficiary; // token可以被释放的时间戳 uint256 public releaseTime; // 对token，受益人address和释放时间初始化 constructor( ERC20Basic _token, address _beneficiary, uint256 _releaseTime ) public &#123; require(_releaseTime &gt; block.timestamp); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; &#125; /** * @notice 将时间限制内的token转移给受益人. */ function release() public &#123; require(block.timestamp &gt;= releaseTime); uint256 amount = token.balanceOf(this); require(amount &gt; 0); token.safeTransfer(beneficiary, amount); &#125;&#125; TokenTimelock 合约通过初始化受益人以及释放的时间和锁定的 token，通过release来将锁定期过后释放的 token 转给受益人 TokenVesting.sol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118pragma solidity ^0.4.23;import &quot;./ERC20Basic.sol&quot;;import &quot;./SafeERC20.sol&quot;;import &quot;../../ownership/Ownable.sol&quot;;import &quot;../../math/SafeMath.sol&quot;;/** * @title TokenVesting 定期释放token * @dev token持有人合同可以逐渐释放token余额典型的归属方案，有断崖时间和归属期, 可选择可撤销的所有者。 */contract TokenVesting is Ownable &#123; using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); // 释放后的token收益人 address public beneficiary; uint256 public cliff; //断崖表示「锁仓4年，1年之后一次性解冻25%」中的一年 uint256 public start;//起始时间 uint256 public duration;//持续锁仓时间 bool public revocable; mapping (address =&gt; uint256) public released; mapping (address =&gt; bool) public revoked; /** * @dev 创建一份归属权合同，将任何ERC20 token的余额归属给_beneficiary,逐渐以线性方式，直到_start + _duration 所有的余额都将归属。 * @param _beneficiary 授予转让token的受益人的地址 * @param _cliff 持续时间以秒为单位，代币将开始归属 * @param _start 归属开始的时间（如Unix时间) * @param _duration 持续时间以token的归属期限为单位 * @param _revocable 归属是否可撤销 */ constructor( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable ) public &#123; require(_beneficiary != address(0)); require(_cliff &lt;= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; &#125; /** * @notice 将归属代币转让给受益人. * @param token ERC20 token which is being vested */ function release(ERC20Basic token) public &#123; uint256 unreleased = releasableAmount(token); require(unreleased &gt; 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); emit Released(unreleased); &#125; /** * @notice允许所有者撤销归属。 token已经归属合约，其余归还给所有者。 * @param token ERC20 token which is being vested */ function revoke(ERC20Basic token) public onlyOwner &#123; require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); emit Revoked(); &#125; /** * @dev 计算已归属但尚未释放的金额。 * @param token ERC20 token which is being vested */ function releasableAmount(ERC20Basic token) public view returns (uint256) &#123; return vestedAmount(token).sub(released[token]); &#125; /** * @dev 计算已归属的金额. * @param token ERC20 token which is being vested */ function vestedAmount(ERC20Basic token) public view returns (uint256) &#123; uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (block.timestamp &lt; cliff) &#123; return 0; &#125; else if (block.timestamp &gt;= start.add(duration) || revoked[token]) &#123; return totalBalance; &#125; else &#123; return totalBalance.mul(block.timestamp.sub(start)).div(duration); &#125; &#125;&#125; TokenVesting 也是锁仓的一种方式，主要解决的是有断崖时间和持续锁仓时间的锁仓场景 PausableToken.sol1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768pragma solidity ^0.4.23;import &quot;./StandardToken.sol&quot;;import &quot;../../lifecycle/Pausable.sol&quot;;/** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/contract PausableToken is StandardToken, Pausable &#123; function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) &#123; return super.transfer(_to, _value); &#125; function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) &#123; return super.transferFrom(_from, _to, _value); &#125; function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) &#123; return super.approve(_spender, _value); &#125; function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) &#123; return super.increaseApproval(_spender, _addedValue); &#125; function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) &#123; return super.decreaseApproval(_spender, _subtractedValue); &#125;&#125; PausableToken 继承了 StandardToken，但是在方法中都添加了whenNotPaused函数修改器，whenNotPaused 继承自 Pausable 合约，Pausable 有个 paused 来标记暂停的状态，从而控制合约的是否暂停。 OpenZeppelin ERC20 源码分析到这里就结束了。 转载自Ryan 是菜鸟 | LNMP 技术栈笔记]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
        <tag>区块链</tag>
        <tag>ERC20</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS]]></title>
    <url>%2F2018%2F09%2F13%2Fipfs%2F</url>
    <content type="text"><![CDATA[IPFS的全称是InterPlanetary File System星际文件系统，是一个点对点的网络超媒体协议。它的目标是成为更快、更安全、更开放的下一代互联网。 IPFS介绍IPFS尝试解决HTTP目前存在的四个问题：. 服务低效，成本高。这也是大部分P2P服务比中心化服务器优秀的地方。 . 网络服务受限于供应商，文件具有无法永久保存的风险，更无法历史回溯。 . 中心化的网络权力过于集中，网络控制和监管某些程度上限制了科技创新。 . 互联网服务大多依赖于骨干网络，一旦宕机大部分服务将无法使用。 IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。 在IPFS网络上，每个IPFS上的文件都具备一个唯一的哈希码。IPFS同时具备了文件去重和历史版本的功能，每个网络节点会存储自己感兴趣的内容，并且索引其它内容的位置，用户可以通过哈希码来寻找到每个文件的具体位置。此外IPFS本身还自带一个IPNS的域名，可以把你的内容和你的个人域名进行绑定。 IPFS的下载与安装可参考官网：https://ipfs.io/docs/install ，备注：目前需要科学上网才能访问 本文以mac环境下安装为例进行说明（mac下也可以用homebrew执行brew install ipfs进行安装），在terminal内输入以下命令进行下载与安装。本文时间(2018.9.13)的最新版本为v0.4.17， 123tar go-ipfs_v0.4.17_darwin-amd64.tar.gzcd go-ipfs./install.sh 安装后使用help命令，可以测试是否成功。 ipfs help IPFS的启动使用参考：https://ipfs.io/docs/getting-started 首先进行初始化，创建一个全局的本地仓库与配置文件。 ipfs init 然后需要开启IPFS的进程从而与网络保持连接状态。这里加上&amp;是为了让进程在后台运行，可以在开启后同时按CTRL键C键回到之前界面。 ipfs daemon &amp; 可以通过下面的命令查看我们在IPFS网络上已经连接的节点 ipfs swarm peers IPFS的使用这里讲解一下hexo搭建的个人博客上传到IPFS网络上。hexo搭建个人博客请移步至hexo+next搭建个人博客，并发布到git pages 1、使用命令ipfs id查看你的电脑的ipfs id 2、修改全局配置_config.yml中的root为/ipns/${ipfsId},其中的ipfsId为你电脑对应的ipfs id 3、在你的hexo搭建的博客根目录下执行如下命令打包生成对应的静态文件。 hexo generate（hexo g也可以） 4、通过ipfs add命令，直接把项目直接添加到IPFS网络。 ipfs add -r public/ 5、通过ipfs name pulished命令，把项目绑定到IPNS。 ipfs name publish QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8 完成这一步后，你应该会在Terminal里看到如下运行结果，你的ipfs id标识了你的文件在网路上的位置。 Published to 你的ipfs id: /ipfs/QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8 6、现在你的文件已经在IPFS上了，网络为了避免垃圾资源过度的情况会在一段时间之后清空数据。为了保证我们的文件能够一直保持在IPFS网络上，我们需要执行pin命令，这样只要你的IPFS进程还开启着，数据就不会被垃圾回收。 ipfs pin add -r QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8 现在你的个人网站已经搭建在了一个完全去中心化的网络上了。你可以通过网址 https://gateway.ipfs.io/ipns/你的ipfsId 访问你的个人主页，也可以通过http://127.0.0.1:8080/ipns/你的ipfsId 。另外要注意的是，IPFS的网关目前需要科学上网才能连接，当然，在没有优化之前，访问会很慢，但可以打开。 7、 绑定独立域名将博客发布到了IPFS运行的区块链节点上，但复杂的site_hash并不友好，我们可以使用IPNS技术，通过绑定独立域名来实现与现有的网站访问并无任何不一样的体现。我们假设你已经有一个可以正常使用的域名，如aa.com，没有域名的可以到任意域名服务商初购买。 有了域名之后，为域名aa.com添加TXT记录为dnslink=/ipns/你的ipfsId,同时将域名A记录指向任意ipfs节点的ip，如gateway.ipfs.io。 现在访问aa.com，你是不是发现已经可以正常访问你刚才生成的博客了。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Next 搭建个人博客]]></title>
    <url>%2F2018%2F09%2F12%2Fhexo%2F</url>
    <content type="text"><![CDATA[突然有了写博客的想法，今天就研究了下如何搭建自己的博客，之后看到了比较流行的组合为Hexo + Next + Git pages，于事就一步步搭建了自己的博客，中间也踩了很多坑，因此想把这个经过记录下来，希望能帮到一些想搭建自己的博客的同志们。 为什么选择HexoHexo 是一个快速、简洁且高效的静态站点生成框架，它基于 Node.js 。 它有以下特点： 超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到Github Pages，或其他网站 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。 基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的主题。 NexT 因其 精于心，简于形 的风格，一直被广大用户所喜爱。 环境要求安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装: Node.jsGit 安装 Git Mac：一般情况下自带git无需安装，如未安装使用 Homebrew，MacPorts 或下载 安装程序 安装 Windows：下载安装 git 。 Download Now 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。（nvm：Node Version Manager） Mac 下安装 nvm1、执行如下命令，需要先安装Git 12$ cd ~/$ git clone https://github.com/creationix/nvm.git .nvm 2、将以下代码添加到 ~/.bashrc, ~/.profile, 或者 ~/.zshrc 文件中，然后执行命令source ~/.bashrc重启配置信息 123export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh" # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion" # This loads nvm bash_completion Windows 下安装 nvm首先需要下载安装nvm-windows， Download Now 安装完nvm以后，我们可以打开命令行中执行命令 12$ nvm$ nvm install latest 执行完以后，重启命令行，执行命令 node -v ，如果出现版本号，那么 Node.js 就安装成功了。 如果没有安装成功，那可能就是墙的原因。建议下载 Node.js 直接安装。 Download Now 安装 Hexo有了 Node.js ，我们可以使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 安装 Hexo 完成后，我们首先需要为我们的项目创建一个指定文件夹（例如我创建了一个文件夹blog 。/Users/yq/blog ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。 1$ hexo init 等待安装，安装完成后，指定文件夹 的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── 我们继续执行命令 12$ hexo g$ hexo s --debug Hexo 将 source 文件夹中除 _posts 文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。这个时候，我们在浏览器中访问 http://localhost:4000/ ，就可以看到基于 Hexo 的默认主题的原型： 安装 NexT 主题1、下载 NexT 主题依旧是在当前目录下，执行如下命令： 1$ git clone https://github.com/theme-next/hexo-theme-next themes/next 等待下载完成。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 我们将前者称为 站点配置文件，后者称为 主题配置文件 2、启用 NexT 主题打开 站点配置文件 ，找到 theme 字段，并将其值更改为 next 。到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 hexo clean 来清除 Hexo 的缓存。 3、验证主题首先启动 Hexo 本地站点，并开启调试模式（即加上 --debug），整个命令是 hexo s --debug。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000/ ，检查站点是否正确运行。 当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse 现在，我们已经成功安装并启用了 NexT 主题。 关于更多基本操作和基础知识，请查阅 Hexo 与 NexT 官方文档. Local Search 配置添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，启用本地搜索功能： 12local_search: enable: true 插件这些功能之前是使用修改源代码方式，现在可以使用 “包/插件引入 + 选项配置” 的方式激活该功能。 插件路径定义在 themes\next\source\lib 目录下。 功能 插件 引入方式 配置项 字数统计 hexo-symbols-count-time 包 heme.symbols_count_time 图片浏览 theme-next-fancybox3 插件 theme.fancybox 顶部进度条 theme-next-pace 插件 theme.pace leancloud访问计数 leancloud-visitors 插件 theme.leancloud_visitors canvas-nest线条动画 canvas-nest 插件 theme.canvas_nest 1.引入方式 以包方式引入比较简单，使用 命令 npm install -save 即可。 以插件方式引入，在 theme\next 目录使用代码克隆命令。 1git clone &lt;github-url&gt; source\lib\&lt;plugin-name&gt; canvas-next 将配置文件中颜色改为：0,0,0 2.进度条 进度条使用 pace.js 插件，点此 查看每个配置的效果图。 鼠标点击小红心的设置 将 love.js 文件添加到 \themes\next\source\js 文件目录下。 找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/love.js"&gt;&lt;/script&gt; 修改文章内链接文本样式将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式： 12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 修改作者头像（圆形）文件\themes\next\source\css\_common\components\sidebar\sidebar-author.styl中.site-author-image 追加以下样式 1234567.site-author-image &#123; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf;&#125; 修改文章底部的那个带#号的标签编辑 主题配置文件 1tag_icon: true 百度统计 注意： baidu_analytics 不是你的百度 id 或者 百度统计 id 登录 百度统计 ，定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如下图所示： 编辑主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 发布到GitHub创建新仓库Github Pages分为两类，用户或组织主页，项目主页。 创建用户或组织主页，只需创建一个名称为{yourusername}.github.io的新仓库即可。这边的yourusername填写自己的用户名。Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。创建项目主页。先新建一个仓库，名称随意，或是使用原有的仓库都可以。在项目主页 -&gt; Settings -&gt; Options -&gt; Github Pages中，将Source选项置为master branch(如果无法设置就先选择一个主题)，然后Save，这个项目就变成一个Github Pages项目了。 安装deploy插件1$ npm install hexo-deployer-git --save 配置发布信息修改主题配置文件中的仓库信息 12345deploy: type: git repo: &lt;repository url&gt; # 仓库地址，例如我的是https://github.com/yqsailor/yqsailor.github.io branch: [branch] # 仓库分支，一般为master message: [message] # git提交注释，此项可留空 总结本地调试步骤三部曲： 123$ hexo clean$ hexo g$ hexo s --debug 这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。 部署步骤三部曲： 123$ hexo clean$ hexo g$ hexo d 当然在部署之前，需要先配置好配置文件中的 deploy。 常用命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" # 新建页面$ hexo generate # 生成静态页面至public目录$ hexo server # 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)$ hexo deploy # 项目部署$ hexo help # 查看帮助$ hexo version # 查看Hexo的版本 简写命令1234$ hexo new == hexo n$ hexo generate == hexo g$ hexo server == hexo s$ hexo deploy == hexo d 常见问题1在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：正确的设置： 123author: yqemail: yqsailor@gmail.comlanguage: zh-CN 常见问题2关于 Git 提交中用户名和 Email 的设置 12git config --global user.name &quot;Your name&quot;git config --global user.email &quot;Your email&quot; 常见问题3Hexo 中的图标使用的是 Font Awesome ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。 &lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt; 常见问题4Hexo 中使用markdown语法的绝对图片路径在首页无法展示，可改用标签插件语法：配置_config.yml 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。 图片_posts/post_name/image.jpg,可通过如下方式访问 1&#123;% asset_img image.jpg This is an image %&#125; 最后要说的是： 博客源码， 欢迎 star]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
</search>
