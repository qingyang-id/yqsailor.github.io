<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sailor&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/f0a11b74c6f6203dc74f7202fbe88c6a</icon>
  <subtitle>Stay Hungry,Stay Foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yqsailor.github.io/"/>
  <updated>2019-06-19T12:55:46.302Z</updated>
  <id>http://yqsailor.github.io/</id>
  
  <author>
    <name>Sailor</name>
    <email>yqsailor@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 搭建 Shadowsocks VPN服务</title>
    <link href="http://yqsailor.github.io/2019/06/18/shadowsocks/"/>
    <id>http://yqsailor.github.io/2019/06/18/shadowsocks/</id>
    <published>2019-06-18T09:00:01.000Z</published>
    <updated>2019-06-19T12:55:46.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司的VPN被封了，因此就注册了AWS，搭建自己的shadowsocks代理服务器，实现科学上网。AWS为新用户提供了一年每月750小时和30G流量的1核1G服务器，当然也可以选择google云，也为新用户提供了一年的免费试用。</p><h1 id="安装PIP"><a href="#安装PIP" class="headerlink" title="安装PIP"></a>安装PIP</h1><h2 id="Debian-Ubuntu下使用"><a href="#Debian-Ubuntu下使用" class="headerlink" title="Debian/Ubuntu下使用"></a>Debian/Ubuntu下使用</h2><p>本教程使用Python 3为载体，因Python 3对应的包管理器pip3并未预装，首先安装pip3：</p><p>Ubuntu16 安装pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure></p><p>Ubuntu18 安装pip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure></p><h2 id="Centos下使用"><a href="#Centos下使用" class="headerlink" title="Centos下使用"></a>Centos下使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y epel-release</span><br><span class="line">sudo yum install python3-pip</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="安装Shadowsocks"><a href="#安装Shadowsocks" class="headerlink" title="安装Shadowsocks"></a>安装Shadowsocks</h1><p>因Shadowsocks作者不再维护pip中的Shadowsocks（定格在了2.8.2），我们使用下面的命令来安装最新版的Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install --upgrade git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><p>安装完成后可以使用下面这个命令查看Shadowsocks版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ssserver --version</span><br></pre></td></tr></table></figure><p>目前会显示“Shadowsocks 3.0.0”。</p><h1 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h1><p>创建Shadowsocks配置文件所在文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /etc/shadowsocks</span><br></pre></td></tr></table></figure><p>然后创建配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure></p><p>复制粘贴如下内容（注意修改密码“password”）：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">8388</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"chacha20"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>“server” ；服务器IP，不用更改<br>“server_port” ；服务器端口，即用于给用户连接的端口，范围0-65535，任选一个端口，只要不与常用端口冲突就行，不过不推荐使用80\443等网站用端口，也不推荐大多数ss的默认端口8388<br>“local_address” ；本机地址，不用更改<br>“local_port” ；本地端端口，不用更改<br>“password” ；账户的密码<br>“timeout” ；超时时间（秒），不用改<br>“method” ；加密方式，推荐用 chacha20 ，不用默认的 rc4-md5 或者 aes-256-cfb，因为默认的太多人用，容易被墙<br>“fast_open” ；true 或 false。如果服务器 Linux 内核在 3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可<br>多个账号：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,  </span><br><span class="line">    <span class="attr">"port_password"</span>:&#123;  </span><br><span class="line">     "8381":"xxx",  // xxx为端口对应的密码 </span><br><span class="line">     "8382":"xxx",  </span><br><span class="line">     "8383":"xxx",  </span><br><span class="line">     "8384":"xxx"  </span><br><span class="line">     &#125;,  </span><br><span class="line">    "local_address": "127.0.0.1",</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "timeout":300,  </span><br><span class="line">    "method":"chacha20",  </span><br><span class="line">    "fast_open": false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="测试Shadowsocks配置"><a href="#测试Shadowsocks配置" class="headerlink" title="测试Shadowsocks配置"></a>测试Shadowsocks配置</h1><p>启动shadowsocks<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure></p><p>在Shadowsocks客户端添加服务器，如果你使用的是我提供的那个配置文件的话，地址为服务器外网IP，端口号为8388，加密方法为chacha20，密码为你设置的密码。然后设置客户端使用全局模式，浏览器登录Google试试应该能直接打开了。</p><p>这时浏览器访问<a href="http://ip138.com" target="_blank" rel="noopener">ip138</a>就会显示Shadowsocks服务器的IP啦！</p><p>测试完毕，按Ctrl + C关闭Shadowsocks。</p><p>如果无法使用，可能是端口未开放，防火墙需开放8388端口</p><h1 id="配置Systemd管理Shadowsocks"><a href="#配置Systemd管理Shadowsocks" class="headerlink" title="配置Systemd管理Shadowsocks"></a>配置Systemd管理Shadowsocks</h1><p>新建Shadowsocks管理文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>复制粘贴：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>保存文件并退出。</p><p>启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start shadowsocks-server</span><br></pre></td></tr></table></figure><p>设置开机启动Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> shadowsocks-server</span><br></pre></td></tr></table></figure><p>查看Shadowsocks状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status shadowsocks-server</span><br></pre></td></tr></table></figure><p>至此，Shadowsock服务器端的基本配置已经全部完成了！</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>这部分属于进阶操作，在你使用Shadowsocks时感觉到延迟较大，或吞吐量较低时，可以考虑对服务器端进行优化。</p><h2 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h2><p>BBR系Google最新开发的TCP拥塞控制算法，目前有着较好的带宽提升效果，甚至不比老牌的锐速差。</p><h2 id="升级Linux内核"><a href="#升级Linux内核" class="headerlink" title="升级Linux内核"></a>升级Linux内核</h2><p>BBR在Linux kernel 4.9引入。首先检查服务器kernel版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>如果其显示版本在4.9.0之下，则需要升级Linux内核，否则请忽略下文。</p><p>更新包管理器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>查看可用的Linux内核版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-cache showpkg linux-image</span><br></pre></td></tr></table></figure><p>找到一个你想要升级的Linux内核版本，如“linux-image-4.10.0-22-generic”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install linux-image-4.10.0-22-generic</span><br></pre></td></tr></table></figure><p>等待安装完成后重启服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>删除老的Linux内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo purge-old-kernels</span><br></pre></td></tr></table></figure><p>开启BBR<br>运行lsmod | grep bbr，如果结果中没有tcp_bbr，则先运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe tcp_bbr</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"tcp_bbr"</span> &gt;&gt; /etc/modules-load.d/modules.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>保存生效。运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>若均有bbr，则开启BBR成功。</p><p>优化吞吐量<br>新建配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/sysctl.d/local.conf</span><br></pre></td></tr></table></figure><p>复制粘贴：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># max open files</span></span><br><span class="line">fs.file-max = 51200</span><br><span class="line"><span class="comment"># max read buffer</span></span><br><span class="line">net.core.rmem_max = 67108864</span><br><span class="line"><span class="comment"># max write buffer</span></span><br><span class="line">net.core.wmem_max = 67108864</span><br><span class="line"><span class="comment"># default read buffer</span></span><br><span class="line">net.core.rmem_default = 65536</span><br><span class="line"><span class="comment"># default write buffer</span></span><br><span class="line">net.core.wmem_default = 65536</span><br><span class="line"><span class="comment"># max processor input queue</span></span><br><span class="line">net.core.netdev_max_backlog = 4096</span><br><span class="line"><span class="comment"># max backlog</span></span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># resist SYN flood attacks</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># reuse timewait sockets when safe</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="comment"># turn off fast timewait sockets recycling</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"><span class="comment"># short FIN timeout</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="comment"># short keepalive time</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"><span class="comment"># outbound port range</span></span><br><span class="line">net.ipv4.ip_local_port_range = 10000 65000</span><br><span class="line"><span class="comment"># max SYN backlog</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"><span class="comment"># max timewait sockets held by system simultaneously</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"><span class="comment"># turn on TCP Fast Open on both client and server side</span></span><br><span class="line">net.ipv4.tcp_fastopen = 3</span><br><span class="line"><span class="comment"># TCP receive buffer</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096 87380 67108864</span><br><span class="line"><span class="comment"># TCP write buffer</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096 65536 67108864</span><br><span class="line"><span class="comment"># turn on path MTU discovery</span></span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure></p><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>编辑之前的shadowsocks-server.service文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks-server.service</span><br></pre></td></tr></table></figure><p>在ExecStart前插入一行，内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStartPre=/bin/sh -c <span class="string">'ulimit -n 51200'</span></span><br></pre></td></tr></table></figure><p>即修改后的shadowsocks-server.service内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStartPre=/bin/sh -c <span class="string">'ulimit -n 51200'</span></span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/ssserver -c /etc/shadowsocks/config.json</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p><p>Ctrl + O保存文件，Ctrl + X退出。</p><p>重载shadowsocks-server.service：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure><p>开启TCP Fast Open<br>TCP Fast Open可以降低Shadowsocks服务器和客户端的延迟。实际上在上一步已经开启了TCP Fast Open，现在只需要在Shadowsocks配置中启用TCP Fast Open。</p><p>编辑config.json：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks/config.json</span><br></pre></td></tr></table></figure><p>将fast_open的值由false修改为true。Ctrl + O保存文件，Ctrl + X退出。</p><p>重启Shadowsocks：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart shadowsocks-server</span><br></pre></td></tr></table></figure><p>注意：TCP Fast Open同时需要客户端的支持，即客户端Linux内核版本为3.7.1及以上；你可以在Shadowsocks客户端中启用TCP Fast Open。</p><p>至此，Shadowsock服务器端的优化已经全部完成了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;公司的VPN被封了，因此就注册了AWS，搭建自己的shadowsocks代理服务器，实现科学上网。AWS为新用户提供了一年每月750小时和30G流量的1核1G服务器，当然也可以选择google云，也为新用户提供了一年的免费试用。&lt;/p&gt;
&lt;h1 id=&quot;安装PIP&quot;&gt;&lt;a href=&quot;#安装PIP&quot; class=&quot;headerlink&quot; title=&quot;安装PIP&quot;&gt;&lt;/a&gt;安装PIP&lt;/h1&gt;&lt;h2 id=&quot;Debian-Ubuntu下使用&quot;&gt;&lt;a href=&quot;#Debian-Ubuntu下使用&quot; class=&quot;headerlink&quot; title=&quot;Debian/Ubuntu下使用&quot;&gt;&lt;/a&gt;Debian/Ubuntu下使用&lt;/h2&gt;&lt;p&gt;本教程使用Python 3为载体，因Python 3对应的包管理器pip3并未预装，首先安装pip3：&lt;/p&gt;
&lt;p&gt;Ubuntu16 安装pip&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install python3-pip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu18 安装pip&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install python3-pip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;Centos下使用&quot;&gt;&lt;a href=&quot;#Centos下使用&quot; class=&quot;headerlink&quot; title=&quot;Centos下使用&quot;&gt;&lt;/a&gt;Centos下使用&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install -y epel-release&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install python3-pip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yqsailor.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Linux" scheme="http://yqsailor.github.io/tags/Linux/"/>
    
      <category term="Shadowsocks" scheme="http://yqsailor.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Linux 搭建 Nginx</title>
    <link href="http://yqsailor.github.io/2019/06/17/nginx/"/>
    <id>http://yqsailor.github.io/2019/06/17/nginx/</id>
    <published>2019-06-17T03:29:29.000Z</published>
    <updated>2019-06-19T09:13:41.553Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 读作 <strong>engine x</strong>， 是一个免费的、开源的、高性能的 HTTP 和反向代理服务，主要负责负载一些访问量比较大的站点。</p><p>Nginx 可以作为一个独立的 Web 服务，也可以用来给 Apache 或是其他的 Web 服务做反向代理。</p><p>相比于 Apache，Nginx 可以处理更多的并发连接，而且每个连接的内存占用的非常小。</p><p>本教程将会教您如何在 Centos 7 的服务器上安装和管理 Nginx。<br><a id="more"></a></p><h2 id="开始前的准备"><a href="#开始前的准备" class="headerlink" title="开始前的准备"></a>开始前的准备</h2><p>在开始阅读此教程之前，请确保你是以拥有<code>sudo</code>权限的用户来登录的服务器，并且服务器中没有 Apache 或是其他服务正在使用 80（HTTP） 和 443（HTTPS） 端口上，防止端口被占用，造成 Nginx 无法正常启动。</p><h2 id="在-CentOS-中安装-Nginx"><a href="#在-CentOS-中安装-Nginx" class="headerlink" title="在 CentOS 中安装 Nginx"></a>在 CentOS 中安装 Nginx</h2><p>请按照下面的步骤，在 CentOS 中安装 Nginx。</p><ol><li>EPEL 仓库中有 Nginx 的安装包。如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure><p>上面代码的意思是以<code>sudo</code>权限运行安装 epel-release，如果你当前登录的用户不是 root，则会提示你输入密码来运行，输入密码时是看不到输入的内容的，所以不用担心，继续输入就行。然后回车继续运行，后面的命令中如果包含<code>sudo</code>则都表明是刚提到的意思，不再重复解释。</p><p><em>2.</em> 输入以下命令来安装 Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><p>如果这是您第一次从 EPEL 仓库中安装软件，yum 可能会提示您导入 EPEL GPG key：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">Importing GPG key 0x352C64E5:</span><br><span class="line">Userid     : <span class="string">"Fedora EPEL (7) &lt;epel@fedoraproject.org&gt;"</span></span><br><span class="line">Fingerprint: 91e9 7d7c 4a5e 96f1 7f3e 888f 6a2f aea2 352c 64e5</span><br><span class="line">Package    : epel-release-7-9.noarch (@extras)</span><br><span class="line">From       : /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7</span><br><span class="line">Is this ok [y/N]:</span><br></pre></td></tr></table></figure></p><p>类似于上面的内容，遇到这种情况，输入<strong><em>y</em></strong>，然后 <strong><em>Enter（回车）</em></strong> 即可继续安装。</p><p><em>3.</em> 等到安装完成以后，可以通过以下命令来设置开机启动和运行 Nginx 服务：</p><p>设置 Nginx 开机启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><p>运行以上命令以后，会输出类似以下的内容，表示创建了一个软连接来关联 Nginx，不用担心，并不是报错了，下一步就可以启动 Nginx 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br></pre></td></tr></table></figure><p>启动 Nginx：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>通过运行以下命令，来检查 Nginx 的运行状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure><p>然后会输出类型下面的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">● nginx.service - The nginx HTTP and reverse proxy server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 一 2019-06-17 20:50:57 CST; 7s ago</span><br><span class="line">  Process: 4857 ExecStart=/usr/sbin/nginx (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 4853 ExecStartPre=/usr/sbin/nginx -t (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 4852 ExecStartPre=/usr/bin/rm -f /run/nginx.pid (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 4859 (nginx)</span><br><span class="line">   CGroup: /system.slice/nginx.service</span><br><span class="line">           ├─4859 nginx: master process /usr/sbin/nginx</span><br><span class="line">           └─4860 nginx: worker process</span><br></pre></td></tr></table></figure><p><em>4.</em> 如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口</p><p>通过下面的命令来打开这两个端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>国内的服务器厂商，安全组也可能会默认屏蔽这两个端口，比如 阿里云 和 腾讯云，如果在 第 5 步 时发现无法访问，可以自行百度一下如何放开这两个端口。</p><p>5、 验证 Nginx 是否成功启动，可以在浏览器中打开 <em><a href="http://YOUR_IP" target="_blank" rel="noopener">http://YOUR_IP</a></em>，您将看到默认的 Nginx 欢迎页面，类似于下图所示：</p><img src="/2019/06/17/nginx/images/nginx.jpeg"><p>注：Nginx 的默认欢迎页有好几种样式，和你安装的版本有关，所以大家只用关注这个页面的大标题就行了 <em>Welcome to nginx！</em></p><h2 id="通过-systemctl-管理-Nginx"><a href="#通过-systemctl-管理-Nginx" class="headerlink" title="通过 systemctl 管理 Nginx"></a>通过 systemctl 管理 Nginx</h2><p>你可以像管理其他服务那样管理 Nginx。</p><p>启动 Nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure><p>停止 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br></pre></td></tr></table></figure><p>重启 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><p>修改 Nginx 配置后，重新加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure><p>设置开机启动 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><p>关闭开机启动 Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl disable nginx</span><br></pre></td></tr></table></figure><h2 id="Nginx-的配置文件和最佳实践"><a href="#Nginx-的配置文件和最佳实践" class="headerlink" title="Nginx 的配置文件和最佳实践"></a>Nginx 的配置文件和最佳实践</h2><p><em>1、</em>通过以上方式安装的 Nginx，所有相关的配置文件都在 /etc/nginx/ 目录中。</p><p><em>2、</em>Nginx 的主配置文件是 /etc/nginx/nginx.conf。</p><p><em>3、</em>为了使 Nginx 配置更易于维护，建议为每个服务（域名）创建一个单独的配置文件。</p><p><em>4、</em>每一个独立的 Nginx 服务配置文件都必须以 .conf 结尾，并存储在 /etc/nginx/conf.d 目录中。您可以根据需求，创建任意多个独立的配置文件。</p><p><em>5、</em>独立的配置文件，建议遵循以下命名约定，比如你的域名是 kaifazhinan.com，那么你的配置文件的应该是这样的 /etc/nginx/conf.d/kaifazhinan.com.conf，如果你在一个服务器中部署多个服务，当然你也可以在文件名中加上 Nginx 转发的端口号，比如 kaifazhinan.com.3000.conf，这样做看起来会更加友好。</p><p><em>6、</em>如果你的配置中有很多重复的代码，那么建议你创建一个 /etc/nginx/snippets 文件夹，在这里面存放所有会被复用的代码块，然后在各个需要用到的 Nginx 的配置文件中引用进去，这样可以更方便管理和修改。</p><p><em>7、</em>Nginx 日志文件（access.log 和 error.log ）位于 /var/log/nginx/ 目录中。建议为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。</p><p><em>8、</em>你可以将要部署的代码文件，存储在任何你想的位置，但是一般推荐存放在下列位置中的其中一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/&lt;user_name&gt;/&lt;site_name&gt;</span><br><span class="line">/var/www/&lt;site_name&gt;</span><br><span class="line">/var/www/html/&lt;site_name&gt;</span><br><span class="line">/opt/&lt;site_name&gt;</span><br><span class="line">/usr/share/nginx/html</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先恭喜你，你已经成功的在 CentOS 7 上安装了 Nginx 服务，你现在可以在你的服务器中通过 Nginx 部署你的服务代码啦。</p><p>期待下次与你相见 : )</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 读作 &lt;strong&gt;engine x&lt;/strong&gt;， 是一个免费的、开源的、高性能的 HTTP 和反向代理服务，主要负责负载一些访问量比较大的站点。&lt;/p&gt;
&lt;p&gt;Nginx 可以作为一个独立的 Web 服务，也可以用来给 Apache 或是其他的 Web 服务做反向代理。&lt;/p&gt;
&lt;p&gt;相比于 Apache，Nginx 可以处理更多的并发连接，而且每个连接的内存占用的非常小。&lt;/p&gt;
&lt;p&gt;本教程将会教您如何在 Centos 7 的服务器上安装和管理 Nginx。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yqsailor.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Nginx" scheme="http://yqsailor.github.io/tags/Nginx/"/>
    
      <category term="Linux" scheme="http://yqsailor.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OpenZeppelin ERC20源码分析</title>
    <link href="http://yqsailor.github.io/2018/09/15/erc20/"/>
    <id>http://yqsailor.github.io/2018/09/15/erc20/</id>
    <published>2018-09-15T09:45:05.000Z</published>
    <updated>2018-09-15T09:06:16.932Z</updated>
    
    <content type="html"><![CDATA[<p>ERC20：Ethereum Request for Comments 20，是一个基于以太坊代币的接口标准（协议）。所有符合 ERC-20 标准的代币都能立即兼容以太坊钱包，它能让用户和交易所，都能非常方便的管理多种代币，转账、存储、ICO 等等。</p><p>OpenZeppelin 的 Token 中实现了 ERC20 的一个安全的合约代码，本篇主要来分析一下源码，了解一下 ERC20 的实现，由于代码之间的调用可能略复杂，直接每个文件每个文件的来看会有点绕，我直接画了一个继承和调用关系的思维导图，可以帮助更容易地看源码。</p><img src="/2018/09/15/erc20/images/open-zeppeline-erc20.png" title="OpenZeppeline ERC20"><a id="more"></a><h1 id="ERC20Basic-sol"><a href="#ERC20Basic-sol" class="headerlink" title="ERC20Basic.sol"></a>ERC20Basic.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">contract ERC20Basic &#123;</span><br><span class="line">  function totalSupply() public view returns (uint256);</span><br><span class="line">  function balanceOf(address who) public view returns (uint256);</span><br><span class="line">  function transfer(address to, uint256 value) public returns (bool);</span><br><span class="line">  event Transfer(address indexed from, address indexed to, uint256 value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ERC20Basic 合约主要定义了 ERC20 的基本接口，定义了必须要实现的方法:</p><p>totalSupply 返回总共发行量<br>balanceOf 查询指定 address 的余额<br>transfer 发送指定数目的 token 到指定账户，同时发送后需要触发Transfer事件<br>Transfer事件,任何 token 发送发生时，必须触发该事件，即使是 0 额度。 当一个 token 合约创建时，应该触发一个 Transfer 事件，token 的发送方是 0x0，也就是说凭空而来的 token，简称空气币。</p><h1 id="ERC20-sol"><a href="#ERC20-sol" class="headerlink" title="ERC20.sol"></a>ERC20.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./ERC20Basic.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract ERC20 is ERC20Basic &#123;</span><br><span class="line">  function allowance(address owner, address spender)</span><br><span class="line">    public view returns (uint256);</span><br><span class="line"></span><br><span class="line">  function transferFrom(address from, address to, uint256 value)</span><br><span class="line">    public returns (bool);</span><br><span class="line"></span><br><span class="line">  function approve(address spender, uint256 value) public returns (bool);</span><br><span class="line">  event Approval(</span><br><span class="line">    address indexed owner,</span><br><span class="line">    address indexed spender,</span><br><span class="line">    uint256 value</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ERC20 合约继承了 ERC20Basic，另外定义了 approve 相关的方法:</p><p>allowance 获取指定用户的批准额度，控制代币的交易，如可交易账号及资产, 控制 Token 的流通<br>transferFrom 从一个地址向另外一个地址转账指定额度的 token，这个方法可以理解为一个收款流程，允许合约来代表 token 持有者发送代币。比如，合约可以帮助你向另外一个人发送 token 或者索要 token。前提是 token 拥有者必须要通过某些机制对这个请求进行确认，比如通过 MetaMask 进行 confirm。否则，执行将失败。 跟 transfer 一样，即使发送 0 代币，也要触发Transfer事件。<br>approve 批准额度，允许一个账户最多能从你的账户你取现指定额度。重复调用时，以最后一次的额度为主。为了防止攻击，最开始这个额度必须设置为 0。<br>Approval事件，当 approve 被调用时，需要触发该事件。</p><h1 id="DetailedERC20-sol"><a href="#DetailedERC20-sol" class="headerlink" title="DetailedERC20.sol"></a>DetailedERC20.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DetailedERC20 is ERC20 &#123;</span><br><span class="line">  string public name;</span><br><span class="line">  string public symbol;</span><br><span class="line">  uint8 public decimals;</span><br><span class="line"></span><br><span class="line">  constructor(string _name, string _symbol, uint8 _decimals) public &#123;</span><br><span class="line">    name = _name;</span><br><span class="line">    symbol = _symbol;</span><br><span class="line">    decimals = _decimals;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DetailedERC20 主要定义了 token 的展示信息:</p><p>name token 的名称,比如”XXXToken”<br>symbol token 的符号,比如”XXX”<br>decimals token 精确的小数点位数，比如 18</p><h1 id="BasicToken-sol"><a href="#BasicToken-sol" class="headerlink" title="BasicToken.sol"></a>BasicToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./ERC20Basic.sol&quot;;</span><br><span class="line">import &quot;../../math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 实现ERC20基本合约的接口</span><br><span class="line"> * @dev 基本的StandardToken，不包含allowances.</span><br><span class="line"> */</span><br><span class="line">contract BasicToken is ERC20Basic &#123;</span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">  mapping(address =&gt; uint256) balances;</span><br><span class="line"></span><br><span class="line">  uint256 totalSupply_;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev 返回存在的token总数</span><br><span class="line">  */</span><br><span class="line">  function totalSupply() public view returns (uint256) &#123;</span><br><span class="line">    return totalSupply_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev 给特定的address转token</span><br><span class="line">  * @param _to 要转账到的address</span><br><span class="line">  * @param _value 要转账的金额</span><br><span class="line">  */</span><br><span class="line">  function transfer(address _to, uint256 _value) public returns (bool) &#123;</span><br><span class="line">    //做相关的合法验证</span><br><span class="line">    require(_to != address(0));</span><br><span class="line">    require(_value &lt;= balances[msg.sender]);</span><br><span class="line">    // msg.sender余额中减去额度，_to余额加上相应额度</span><br><span class="line">    balances[msg.sender] = balances[msg.sender].sub(_value);</span><br><span class="line">    balances[_to] = balances[_to].add(_value);</span><br><span class="line">    //触发Transfer事件</span><br><span class="line">    emit Transfer(msg.sender, _to, _value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">  * @dev 获取指定address的余额</span><br><span class="line">  * @param _owner 查询余额的address.</span><br><span class="line">  * @return An uint256 representing the amount owned by the passed address.</span><br><span class="line">  */</span><br><span class="line">  function balanceOf(address _owner) public view returns (uint256) &#123;</span><br><span class="line">    return balances[_owner];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过SafeMath来做运算很重要，在我们自己写合约的时候也尽量使用，可以避免一些计算过程的溢出等安全问题。</p><h1 id="StandardToken-sol"><a href="#StandardToken-sol" class="headerlink" title="StandardToken.sol"></a>StandardToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./BasicToken.sol&quot;;</span><br><span class="line">import &quot;./ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 标准 ERC20 token</span><br><span class="line"> *</span><br><span class="line"> * @dev 实现基础的标准token</span><br><span class="line"> * @dev https://github.com/ethereum/EIPs/issues/20</span><br><span class="line"> * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol</span><br><span class="line"> */</span><br><span class="line">contract StandardToken is ERC20, BasicToken &#123;</span><br><span class="line">  mapping (address =&gt; mapping (address =&gt; uint256)) internal allowed;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 从一个地址向另外一个地址转token</span><br><span class="line">   * @param _from 转账的from地址</span><br><span class="line">   * @param _to address 转账的to地址</span><br><span class="line">   * @param _value uint256 转账token数量</span><br><span class="line">   */</span><br><span class="line">  function transferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _value</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    // 做合法性检查</span><br><span class="line">    require(_to != address(0));</span><br><span class="line">    require(_value &lt;= balances[_from]);</span><br><span class="line">    require(_value &lt;= allowed[_from][msg.sender]);</span><br><span class="line">    //_from余额减去相应的金额</span><br><span class="line">    //_to余额加上相应的金额</span><br><span class="line">    //msg.sender可以从账户_from中转出的数量减少_value</span><br><span class="line">    balances[_from] = balances[_from].sub(_value);</span><br><span class="line">    balances[_to] = balances[_to].add(_value);</span><br><span class="line">    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);</span><br><span class="line">    // 触发Transfer事件</span><br><span class="line">    emit Transfer(_from, _to, _value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 批准传递的address以代表msg.sender花费指定数量的token</span><br><span class="line">   *</span><br><span class="line">   * Beware that changing an allowance with this method brings the risk that someone may use both the old</span><br><span class="line">   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this</span><br><span class="line">   * race condition is to first reduce the spender&apos;s allowance to 0 and set the desired value afterwards:</span><br><span class="line">   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span><br><span class="line">   * @param _spender 花费资金的地址</span><br><span class="line">   * @param _value 可以被花费的token数量</span><br><span class="line">   */</span><br><span class="line">  function approve(address _spender, uint256 _value) public returns (bool) &#123;</span><br><span class="line">    //记录msg.sender允许_spender动用的token</span><br><span class="line">    allowed[msg.sender][_spender] = _value;</span><br><span class="line">    //触发Approval事件</span><br><span class="line">    emit Approval(msg.sender, _spender, _value);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 函数检查所有者允许的_spender花费的token数量</span><br><span class="line">   * @param _owner address 资金所有者地址.</span><br><span class="line">   * @param _spender address 花费资金的spender的地址.</span><br><span class="line">   * @return A uint256 指定_spender仍可用token的数量。</span><br><span class="line">   */</span><br><span class="line">  function allowance(</span><br><span class="line">    address _owner,</span><br><span class="line">    address _spender</span><br><span class="line">   )</span><br><span class="line">    public</span><br><span class="line">    view</span><br><span class="line">    returns (uint256)</span><br><span class="line">  &#123;</span><br><span class="line">    //允许_spender从_owner中转出的token数</span><br><span class="line">    return allowed[_owner][_spender];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 增加所有者允许_spender花费代币的数量。</span><br><span class="line">   *</span><br><span class="line">   * allowed[_spender] == 0时approve应该被调用. 增加allowed值最好使用此函数避免2此调用（等待知道第一笔交易被挖出）</span><br><span class="line">   * From MonolithDAO Token.sol</span><br><span class="line">   * @param _spender 花费资金的地址</span><br><span class="line">   * @param _addedValue 用于增加允许动用的token牌数量</span><br><span class="line">   */</span><br><span class="line">  function increaseApproval(</span><br><span class="line">    address _spender,</span><br><span class="line">    uint _addedValue</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    //在之前允许的数量上增加_addedValue</span><br><span class="line">    allowed[msg.sender][_spender] = (</span><br><span class="line">      allowed[msg.sender][_spender].add(_addedValue));</span><br><span class="line">    //触发Approval事件</span><br><span class="line">    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 减少所有者允许_spender花费代币的数量</span><br><span class="line">   *</span><br><span class="line">   * allowed[_spender] == 0时approve应该被调用. 减少allowed值最好使用此函数避免2此调用（等待知道第一笔交易被挖出）</span><br><span class="line">   * From MonolithDAO Token.sol</span><br><span class="line">   * @param _spender  花费资金的地址</span><br><span class="line">   * @param _subtractedValue 用于减少允许动用的token牌数量</span><br><span class="line">   */</span><br><span class="line">  function decreaseApproval(</span><br><span class="line">    address _spender,</span><br><span class="line">    uint _subtractedValue</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    uint oldValue = allowed[msg.sender][_spender];</span><br><span class="line">    if (_subtractedValue &gt; oldValue) &#123;</span><br><span class="line">    //减少的数量少于之前允许的数量，则清零</span><br><span class="line">      allowed[msg.sender][_spender] = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    //减少对应的_subtractedValue数量</span><br><span class="line">      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);</span><br><span class="line">    &#125;</span><br><span class="line">    //触发Approval事件</span><br><span class="line">    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面合约定义的 mapping allowed，它用来记录某个地址允许另外一个地址动用多少 token。假设钱包地址为 B，有另外一个合约其合约地址为 C，合约 C 会通过支付 XXX Token 来做一些事情，根据 ERC20 的定义，每个地址只能操作属于自己的 Token，则合约 C 无法直接使用 B 地址所拥有的 Token，这时候 allowed Mapping 就派上用场了，它上面可以记录一个允许操作值，像是「B 钱包地址允许 C 合约地址动用属于 B 钱包地址的 1000 XXX Token」，以 Mapping 的结构来说标记为「B =&gt; C =&gt; 1000」</p><h1 id="BurnableToken-sol"><a href="#BurnableToken-sol" class="headerlink" title="BurnableToken.sol"></a>BurnableToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./BasicToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 可销毁 Token</span><br><span class="line"> * @dev Token可以被不可逆转地销毁</span><br><span class="line"> */</span><br><span class="line">contract BurnableToken is BasicToken &#123;</span><br><span class="line"></span><br><span class="line">  event Burn(address indexed burner, uint256 value);</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 销毁指定数量的token.</span><br><span class="line">   * @param _value 被销毁的token数量.</span><br><span class="line">   */</span><br><span class="line">  function burn(uint256 _value) public &#123;</span><br><span class="line">    _burn(msg.sender, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function _burn(address _who, uint256 _value) internal &#123;</span><br><span class="line">    require(_value &lt;= balances[_who]);</span><br><span class="line">    //不需要验证value &lt;= totalSupply，因为这意味着发送者的余额大于总供应量，这应该是断言失败</span><br><span class="line">    balances[_who] = balances[_who].sub(_value);</span><br><span class="line">    totalSupply_ = totalSupply_.sub(_value);</span><br><span class="line">    emit Burn(_who, _value);</span><br><span class="line">    emit Transfer(_who, address(0), _value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该合约比较简单，就是调用者可以销毁一定数量的 token，然后 totalSupply 减去对应销毁的数量</p><h1 id="StandardBurnableToken-sol"><a href="#StandardBurnableToken-sol" class="headerlink" title="StandardBurnableToken.sol"></a>StandardBurnableToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./BurnableToken.sol&quot;;</span><br><span class="line">import &quot;./StandardToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 标准可销毁token</span><br><span class="line"> * @dev 将burnFrom方法添加到ERC20实现中</span><br><span class="line"> */</span><br><span class="line">contract StandardBurnableToken is BurnableToken, StandardToken &#123;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 从目标地址销毁特定数量的token并减少允许量</span><br><span class="line">   * @param _from address token所有者地址</span><br><span class="line">   * @param _value uint256 被销毁的token数量</span><br><span class="line">   */</span><br><span class="line">  function burnFrom(address _from, uint256 _value) public &#123;</span><br><span class="line">    require(_value &lt;= allowed[_from][msg.sender]);</span><br><span class="line">    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,</span><br><span class="line">    // 此方法需要触发具有更新批准的事件。</span><br><span class="line">    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);</span><br><span class="line">    _burn(_from, _value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MintableToken-sol"><a href="#MintableToken-sol" class="headerlink" title="MintableToken.sol"></a>MintableToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./StandardToken.sol&quot;;</span><br><span class="line">import &quot;../../ownership/Ownable.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 可增发 token</span><br><span class="line"> * @dev 简单的可增发的 ERC20 Token 示例</span><br><span class="line"> * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120</span><br><span class="line"> * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol</span><br><span class="line"> */</span><br><span class="line">contract MintableToken is StandardToken, Ownable &#123;</span><br><span class="line">  event Mint(address indexed to, uint256 amount);</span><br><span class="line">  event MintFinished();</span><br><span class="line">  //初始化增发状态为false</span><br><span class="line">  bool public mintingFinished = false;</span><br><span class="line"></span><br><span class="line">  modifier canMint() &#123;</span><br><span class="line">    // 检查没有增发结束</span><br><span class="line">    require(!mintingFinished);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  modifier hasMintPermission() &#123;</span><br><span class="line">    //owner只能为msg.sender</span><br><span class="line">    require(msg.sender == owner);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 增发token方法</span><br><span class="line">   * @param _to 获取增发token的地址_to.</span><br><span class="line">   * @param _amount 增发的token数量.</span><br><span class="line">   * @return A boolean that indicates if the operation was successful.</span><br><span class="line">   */</span><br><span class="line">  function mint(</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _amount</span><br><span class="line">  )</span><br><span class="line">    hasMintPermission</span><br><span class="line">    canMint</span><br><span class="line">    public</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    // 总发行量增加_amount数量的token</span><br><span class="line">    totalSupply_ = totalSupply_.add(_amount);</span><br><span class="line">    // 获取增发的地址增加_amount数量的token</span><br><span class="line">    balances[_to] = balances[_to].add(_amount);</span><br><span class="line">    // 触发增发事件</span><br><span class="line">    emit Mint(_to, _amount);</span><br><span class="line">    // 触发Transfer事件</span><br><span class="line">    emit Transfer(address(0), _to, _amount);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 停止增发新token.</span><br><span class="line">   * @return True if the operation was successful.</span><br><span class="line">   */</span><br><span class="line">  function finishMinting() onlyOwner canMint public returns (bool) &#123;</span><br><span class="line">    // 改变增发状态为已完成</span><br><span class="line">    mintingFinished = true;</span><br><span class="line">    // 触发增发已完成事件</span><br><span class="line">    emit MintFinished();</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增发 token 的合约也很简单，就是通过增发一定量的 token 给对应的 address，并给总发行量增加对应的增发 token，可以通过调用finishMinting来完成增发。</p><h1 id="CappedToken-sol"><a href="#CappedToken-sol" class="headerlink" title="CappedToken.sol"></a>CappedToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./MintableToken.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title 上限 token</span><br><span class="line"> * @dev 设置一个顶的可增发token.</span><br><span class="line"> */</span><br><span class="line">contract CappedToken is MintableToken &#123;</span><br><span class="line"></span><br><span class="line">  uint256 public cap;</span><br><span class="line"></span><br><span class="line">  constructor(uint256 _cap) public &#123;</span><br><span class="line">    require(_cap &gt; 0);</span><br><span class="line">    cap = _cap;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 增发token</span><br><span class="line">   * @param _to 获取增发token的地址_to.</span><br><span class="line">   * @param _amount 增发token数量.</span><br><span class="line">   * @return A boolean that indicates if the operation was successful.</span><br><span class="line">   */</span><br><span class="line">  function mint(</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _amount</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    // 验证总发行量+增发量小于所设置的上限</span><br><span class="line">    require(totalSupply_.add(_amount) &lt;= cap);</span><br><span class="line">    // 调用父合约的增发方法</span><br><span class="line">    return super.mint(_to, _amount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CappedToken 也很简单，就是在可增发合约上加了一个”cap”，来限制增发的上限</p><h1 id="RBACMintableToken-sol"><a href="#RBACMintableToken-sol" class="headerlink" title="RBACMintableToken.sol"></a>RBACMintableToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./MintableToken.sol&quot;;</span><br><span class="line">import &quot;../../ownership/rbac/RBAC.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title RBACMintableToken</span><br><span class="line"> * @author Vittorio Minacori (@vittominacori)</span><br><span class="line"> * @dev Mintable Token, with RBAC minter permissions</span><br><span class="line"> */</span><br><span class="line">contract RBACMintableToken is MintableToken, RBAC &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 指定一个增发者的常量名.</span><br><span class="line">   */</span><br><span class="line">  string public constant ROLE_MINTER = &quot;minter&quot;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 重写Mintable token合约的 modifier，增加角色有关的逻辑</span><br><span class="line">   */</span><br><span class="line">  modifier hasMintPermission() &#123;</span><br><span class="line">    // 调用RBAC合约中的角色检查</span><br><span class="line">    checkRole(msg.sender, ROLE_MINTER);</span><br><span class="line">    _;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 将一个地址添加为可增发者角色</span><br><span class="line">   * @param minter address</span><br><span class="line">   */</span><br><span class="line">  function addMinter(address minter) onlyOwner public &#123;</span><br><span class="line">    addRole(minter, ROLE_MINTER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 将一个地址移除可增发者角色</span><br><span class="line">   * @param minter address</span><br><span class="line">   */</span><br><span class="line">  function removeMinter(address minter) onlyOwner public &#123;</span><br><span class="line">    removeRole(minter, ROLE_MINTER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RBACMintableToken 合约将增发操作中添加了 RBAC 逻辑，就是角色权限管理的逻辑，将一个地址这是为增发者角色，也可以移除一个地址的增发者角色，只有拥有”minter”角色的 address 才有权限增发 token</p><h1 id="SafeERC20-sol"><a href="#SafeERC20-sol" class="headerlink" title="SafeERC20.sol"></a>SafeERC20.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./ERC20Basic.sol&quot;;</span><br><span class="line">import &quot;./ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title SafeERC20</span><br><span class="line"> * @dev 围绕ERC20操作发生故障的包装程序.</span><br><span class="line"> * 可以在合约中通过这样使用这个库 `using SafeERC20 for ERC20;` 来使用安全的操作`token.safeTransfer(...)`</span><br><span class="line"> */</span><br><span class="line">library SafeERC20 &#123;</span><br><span class="line">  function safeTransfer(ERC20Basic token, address to, uint256 value) internal &#123;</span><br><span class="line">    require(token.transfer(to, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function safeTransferFrom(</span><br><span class="line">    ERC20 token,</span><br><span class="line">    address from,</span><br><span class="line">    address to,</span><br><span class="line">    uint256 value</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">  &#123;</span><br><span class="line">    require(token.transferFrom(from, to, value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function safeApprove(ERC20 token, address spender, uint256 value) internal &#123;</span><br><span class="line">    require(token.approve(spender, value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SafeERC20 是一个 ERC20 的安全操作库，在下面的TokenTimelock锁定期后释放 token 的合约中我们可以看到用法</p><h1 id="TokenTimelock-sol"><a href="#TokenTimelock-sol" class="headerlink" title="TokenTimelock.sol"></a>TokenTimelock.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./SafeERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title TokenTimelock 锁定期释放token</span><br><span class="line"> * @dev TokenTimelock 是一个令token持有人合同，将允许一个受益人在给定的发布时间之后提取token</span><br><span class="line"> */</span><br><span class="line">contract TokenTimelock &#123;</span><br><span class="line">  //这里用到了上面的SafeERC20</span><br><span class="line">  using SafeERC20 for ERC20Basic;</span><br><span class="line"></span><br><span class="line">  // ERC20 basic token contract being held</span><br><span class="line">  ERC20Basic public token;</span><br><span class="line"></span><br><span class="line">  // token被释放后的受益人address</span><br><span class="line">  address public beneficiary;</span><br><span class="line"></span><br><span class="line">  // token可以被释放的时间戳</span><br><span class="line">  uint256 public releaseTime;</span><br><span class="line">  // 对token，受益人address和释放时间初始化</span><br><span class="line">  constructor(</span><br><span class="line">    ERC20Basic _token,</span><br><span class="line">    address _beneficiary,</span><br><span class="line">    uint256 _releaseTime</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">  &#123;</span><br><span class="line">    require(_releaseTime &gt; block.timestamp);</span><br><span class="line">    token = _token;</span><br><span class="line">    beneficiary = _beneficiary;</span><br><span class="line">    releaseTime = _releaseTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @notice 将时间限制内的token转移给受益人.</span><br><span class="line">   */</span><br><span class="line">  function release() public &#123;</span><br><span class="line">    require(block.timestamp &gt;= releaseTime);</span><br><span class="line"></span><br><span class="line">    uint256 amount = token.balanceOf(this);</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line"></span><br><span class="line">    token.safeTransfer(beneficiary, amount);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TokenTimelock 合约通过初始化受益人以及释放的时间和锁定的 token，通过release来将锁定期过后释放的 token 转给受益人</p><h1 id="TokenVesting-sol"><a href="#TokenVesting-sol" class="headerlink" title="TokenVesting.sol"></a>TokenVesting.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./ERC20Basic.sol&quot;;</span><br><span class="line">import &quot;./SafeERC20.sol&quot;;</span><br><span class="line">import &quot;../../ownership/Ownable.sol&quot;;</span><br><span class="line">import &quot;../../math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title TokenVesting 定期释放token</span><br><span class="line"> * @dev token持有人合同可以逐渐释放token余额典型的归属方案，有断崖时间和归属期, 可选择可撤销的所有者。</span><br><span class="line"> */</span><br><span class="line">contract TokenVesting is Ownable &#123;</span><br><span class="line">  using SafeMath for uint256;</span><br><span class="line">  using SafeERC20 for ERC20Basic;</span><br><span class="line"></span><br><span class="line">  event Released(uint256 amount);</span><br><span class="line">  event Revoked();</span><br><span class="line"></span><br><span class="line">  // 释放后的token收益人</span><br><span class="line">  address public beneficiary;</span><br><span class="line"></span><br><span class="line">  uint256 public cliff; //断崖表示「锁仓4年，1年之后一次性解冻25%」中的一年</span><br><span class="line">  uint256 public start;//起始时间</span><br><span class="line">  uint256 public duration;//持续锁仓时间</span><br><span class="line"></span><br><span class="line">  bool public revocable;</span><br><span class="line"></span><br><span class="line">  mapping (address =&gt; uint256) public released;</span><br><span class="line">  mapping (address =&gt; bool) public revoked;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 创建一份归属权合同，将任何ERC20 token的余额归属给_beneficiary,逐渐以线性方式，直到_start + _duration 所有的余额都将归属。</span><br><span class="line">   * @param _beneficiary 授予转让token的受益人的地址</span><br><span class="line">   * @param _cliff 持续时间以秒为单位，代币将开始归属</span><br><span class="line">   * @param _start 归属开始的时间（如Unix时间)</span><br><span class="line">   * @param _duration 持续时间以token的归属期限为单位</span><br><span class="line">   * @param _revocable 归属是否可撤销</span><br><span class="line">   */</span><br><span class="line">  constructor(</span><br><span class="line">    address _beneficiary,</span><br><span class="line">    uint256 _start,</span><br><span class="line">    uint256 _cliff,</span><br><span class="line">    uint256 _duration,</span><br><span class="line">    bool _revocable</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">  &#123;</span><br><span class="line">    require(_beneficiary != address(0));</span><br><span class="line">    require(_cliff &lt;= _duration);</span><br><span class="line"></span><br><span class="line">    beneficiary = _beneficiary;</span><br><span class="line">    revocable = _revocable;</span><br><span class="line">    duration = _duration;</span><br><span class="line">    cliff = _start.add(_cliff);</span><br><span class="line">    start = _start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @notice 将归属代币转让给受益人.</span><br><span class="line">   * @param token ERC20 token which is being vested</span><br><span class="line">   */</span><br><span class="line">  function release(ERC20Basic token) public &#123;</span><br><span class="line">    uint256 unreleased = releasableAmount(token);</span><br><span class="line"></span><br><span class="line">    require(unreleased &gt; 0);</span><br><span class="line"></span><br><span class="line">    released[token] = released[token].add(unreleased);</span><br><span class="line"></span><br><span class="line">    token.safeTransfer(beneficiary, unreleased);</span><br><span class="line"></span><br><span class="line">    emit Released(unreleased);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @notice允许所有者撤销归属。 token已经归属合约，其余归还给所有者。</span><br><span class="line">   * @param token ERC20 token which is being vested</span><br><span class="line">   */</span><br><span class="line">  function revoke(ERC20Basic token) public onlyOwner &#123;</span><br><span class="line">    require(revocable);</span><br><span class="line">    require(!revoked[token]);</span><br><span class="line"></span><br><span class="line">    uint256 balance = token.balanceOf(this);</span><br><span class="line"></span><br><span class="line">    uint256 unreleased = releasableAmount(token);</span><br><span class="line">    uint256 refund = balance.sub(unreleased);</span><br><span class="line"></span><br><span class="line">    revoked[token] = true;</span><br><span class="line"></span><br><span class="line">    token.safeTransfer(owner, refund);</span><br><span class="line"></span><br><span class="line">    emit Revoked();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 计算已归属但尚未释放的金额。</span><br><span class="line">   * @param token ERC20 token which is being vested</span><br><span class="line">   */</span><br><span class="line">  function releasableAmount(ERC20Basic token) public view returns (uint256) &#123;</span><br><span class="line">    return vestedAmount(token).sub(released[token]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @dev 计算已归属的金额.</span><br><span class="line">   * @param token ERC20 token which is being vested</span><br><span class="line">   */</span><br><span class="line">  function vestedAmount(ERC20Basic token) public view returns (uint256) &#123;</span><br><span class="line">    uint256 currentBalance = token.balanceOf(this);</span><br><span class="line">    uint256 totalBalance = currentBalance.add(released[token]);</span><br><span class="line"></span><br><span class="line">    if (block.timestamp &lt; cliff) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125; else if (block.timestamp &gt;= start.add(duration) || revoked[token]) &#123;</span><br><span class="line">      return totalBalance;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return totalBalance.mul(block.timestamp.sub(start)).div(duration);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TokenVesting 也是锁仓的一种方式，主要解决的是有断崖时间和持续锁仓时间的锁仓场景</p><h1 id="PausableToken-sol"><a href="#PausableToken-sol" class="headerlink" title="PausableToken.sol"></a>PausableToken.sol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.23;</span><br><span class="line"></span><br><span class="line">import &quot;./StandardToken.sol&quot;;</span><br><span class="line">import &quot;../../lifecycle/Pausable.sol&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @title Pausable token</span><br><span class="line"> * @dev StandardToken modified with pausable transfers.</span><br><span class="line"> **/</span><br><span class="line">contract PausableToken is StandardToken, Pausable &#123;</span><br><span class="line"></span><br><span class="line">  function transfer(</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _value</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    whenNotPaused</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    return super.transfer(_to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function transferFrom(</span><br><span class="line">    address _from,</span><br><span class="line">    address _to,</span><br><span class="line">    uint256 _value</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    whenNotPaused</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    return super.transferFrom(_from, _to, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function approve(</span><br><span class="line">    address _spender,</span><br><span class="line">    uint256 _value</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    whenNotPaused</span><br><span class="line">    returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">    return super.approve(_spender, _value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function increaseApproval(</span><br><span class="line">    address _spender,</span><br><span class="line">    uint _addedValue</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    whenNotPaused</span><br><span class="line">    returns (bool success)</span><br><span class="line">  &#123;</span><br><span class="line">    return super.increaseApproval(_spender, _addedValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function decreaseApproval(</span><br><span class="line">    address _spender,</span><br><span class="line">    uint _subtractedValue</span><br><span class="line">  )</span><br><span class="line">    public</span><br><span class="line">    whenNotPaused</span><br><span class="line">    returns (bool success)</span><br><span class="line">  &#123;</span><br><span class="line">    return super.decreaseApproval(_spender, _subtractedValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PausableToken 继承了 StandardToken，但是在方法中都添加了whenNotPaused函数修改器，whenNotPaused 继承自 Pausable 合约，Pausable 有个 paused 来标记暂停的状态，从而控制合约的是否暂停。</p><p>OpenZeppelin ERC20 源码分析到这里就结束了。</p><p>转载自Ryan <a href="https://yuanxuxu.com/2018/06/27/openzeppelin-erc20-code-analysis" target="_blank" rel="noopener">是菜鸟 | LNMP 技术栈笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ERC20：Ethereum Request for Comments 20，是一个基于以太坊代币的接口标准（协议）。所有符合 ERC-20 标准的代币都能立即兼容以太坊钱包，它能让用户和交易所，都能非常方便的管理多种代币，转账、存储、ICO 等等。&lt;/p&gt;
&lt;p&gt;OpenZeppelin 的 Token 中实现了 ERC20 的一个安全的合约代码，本篇主要来分析一下源码，了解一下 ERC20 的实现，由于代码之间的调用可能略复杂，直接每个文件每个文件的来看会有点绕，我直接画了一个继承和调用关系的思维导图，可以帮助更容易地看源码。&lt;/p&gt;
&lt;img src=&quot;/2018/09/15/erc20/images/open-zeppeline-erc20.png&quot; title=&quot;OpenZeppeline ERC20&quot;&gt;
    
    </summary>
    
      <category term="区块链" scheme="http://yqsailor.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="以太坊" scheme="http://yqsailor.github.io/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="区块链" scheme="http://yqsailor.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="ERC20" scheme="http://yqsailor.github.io/tags/ERC20/"/>
    
  </entry>
  
  <entry>
    <title>IPFS</title>
    <link href="http://yqsailor.github.io/2018/09/13/ipfs/"/>
    <id>http://yqsailor.github.io/2018/09/13/ipfs/</id>
    <published>2018-09-13T09:18:28.000Z</published>
    <updated>2019-06-19T09:13:41.552Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ipfs.io/" target="_blank" rel="noopener">IPFS</a>的全称是InterPlanetary File System星际文件系统，是一个点对点的网络超媒体协议。它的目标是成为更快、更安全、更开放的下一代互联网。<br><img src="/2018/09/13/ipfs/images/ipfs-cover.png"></p><h2 id="IPFS介绍"><a href="#IPFS介绍" class="headerlink" title="IPFS介绍"></a>IPFS介绍</h2><h3 id="IPFS尝试解决HTTP目前存在的四个问题："><a href="#IPFS尝试解决HTTP目前存在的四个问题：" class="headerlink" title="IPFS尝试解决HTTP目前存在的四个问题："></a>IPFS尝试解决HTTP目前存在的四个问题：</h3><p>. 服务低效，成本高。这也是大部分P2P服务比中心化服务器优秀的地方。</p><p>. 网络服务受限于供应商，文件具有无法永久保存的风险，更无法历史回溯。</p><p>. 中心化的网络权力过于集中，网络控制和监管某些程度上限制了科技创新。</p><p>. 互联网服务大多依赖于骨干网络，一旦宕机大部分服务将无法使用。</p><h3 id="IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。"><a href="#IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。" class="headerlink" title="IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。"></a>IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。</h3><a id="more"></a><p>在IPFS网络上，每个IPFS上的文件都具备一个唯一的哈希码。IPFS同时具备了文件去重和历史版本的功能，每个网络节点会存储自己感兴趣的内容，并且索引其它内容的位置，用户可以通过哈希码来寻找到每个文件的具体位置。此外IPFS本身还自带一个IPNS的域名，可以把你的内容和你的个人域名进行绑定。</p><h2 id="IPFS的下载与安装"><a href="#IPFS的下载与安装" class="headerlink" title="IPFS的下载与安装"></a>IPFS的下载与安装</h2><p>可参考官网：<a href="https://ipfs.io/docs/install" target="_blank" rel="noopener">https://ipfs.io/docs/install</a> ，备注：目前需要科学上网才能访问</p><p>本文以mac环境下安装为例进行说明（mac下也可以用homebrew执行<code>brew install ipfs</code>进行安装），在terminal内输入以下命令进行下载与安装。本文时间(2018.9.13)的最新版本为v0.4.17，<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar go-ipfs_v0.4.17_darwin-amd64.tar.gz</span><br><span class="line">cd go-ipfs</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure></p><p>安装后使用help命令，可以测试是否成功。</p><p><code>ipfs help</code></p><h3 id="IPFS的启动"><a href="#IPFS的启动" class="headerlink" title="IPFS的启动"></a>IPFS的启动</h3><p>使用参考：<a href="https://ipfs.io/docs/getting-started" target="_blank" rel="noopener">https://ipfs.io/docs/getting-started</a></p><p>首先进行初始化，创建一个全局的本地仓库与配置文件。</p><p><code>ipfs init</code></p><p>然后需要开启IPFS的进程从而与网络保持连接状态。这里加上&amp;是为了让进程在后台运行，可以在开启后同时按CTRL键C键回到之前界面。</p><p><code>ipfs daemon &amp;</code></p><p>可以通过下面的命令查看我们在IPFS网络上已经连接的节点</p><p><code>ipfs swarm peers</code></p><h2 id="IPFS的使用"><a href="#IPFS的使用" class="headerlink" title="IPFS的使用"></a>IPFS的使用</h2><p>这里讲解一下hexo搭建的个人博客上传到IPFS网络上。hexo搭建个人博客请移步至hexo+next搭建个人博客，并发布到git pages</p><p>1、使用命令<code>ipfs id</code>查看你的电脑的ipfs id</p><p>2、修改全局配置_config.yml中的root为<code>/ipns/${ipfsId}</code>,其中的ipfsId为你电脑对应的ipfs id</p><p>3、在你的hexo搭建的博客根目录下执行如下命令打包生成对应的静态文件。</p><p><code>hexo generate（hexo g也可以）</code></p><p>4、通过ipfs add命令，直接把项目直接添加到IPFS网络。</p><p><code>ipfs add -r public/</code></p><img src="/2018/09/13/ipfs/images/ipfs-add.png"><p>5、通过<code>ipfs name pulished</code>命令，把项目绑定到IPNS。</p><p><code>ipfs name publish QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8</code></p><p> 完成这一步后，你应该会在Terminal里看到如下运行结果，你的ipfs id标识了你的文件在网路上的位置。</p><p><code>Published to 你的ipfs id: /ipfs/QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8</code></p><p>6、现在你的文件已经在IPFS上了，网络为了避免垃圾资源过度的情况会在一段时间之后清空数据。为了保证我们的文件能够一直保持在IPFS网络上，我们需要执行pin命令，这样只要你的IPFS进程还开启着，数据就不会被垃圾回收。</p><p><code>ipfs pin add -r QmcmaC834fyeqXuxZmkKd2ukSLsZY5tprGffzCXrpKzAZ8</code></p><p>现在你的个人网站已经搭建在了一个完全去中心化的网络上了。你可以通过网址 <a href="https://gateway.ipfs.io/ipns/你的ipfsId" target="_blank" rel="noopener">https://gateway.ipfs.io/ipns/你的ipfsId</a> 访问你的个人主页，也可以通过<a href="http://127.0.0.1:8080/ipns/你的ipfsId" target="_blank" rel="noopener">http://127.0.0.1:8080/ipns/你的ipfsId</a> 。另外要注意的是，IPFS的网关目前需要科学上网才能连接，当然，在没有优化之前，访问会很慢，但可以打开。</p><p>7、 绑定独立域名<br>将博客发布到了IPFS运行的区块链节点上，但复杂的site_hash并不友好，我们可以使用IPNS技术，通过绑定独立域名来实现与现有的网站访问并无任何不一样的体现。我们假设你已经有一个可以正常使用的域名，如aa.com，没有域名的可以到任意域名服务商初购买。</p><p>有了域名之后，为域名aa.com添加TXT记录为<strong>dnslink=/ipns/你的ipfsId</strong>,同时将域名A记录指向任意ipfs节点的ip，如gateway.ipfs.io。</p><p>现在访问aa.com，你是不是发现已经可以正常访问你刚才生成的博客了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ipfs.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IPFS&lt;/a&gt;的全称是InterPlanetary File System星际文件系统，是一个点对点的网络超媒体协议。它的目标是成为更快、更安全、更开放的下一代互联网。&lt;br&gt;&lt;img src=&quot;/2018/09/13/ipfs/images/ipfs-cover.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;IPFS介绍&quot;&gt;&lt;a href=&quot;#IPFS介绍&quot; class=&quot;headerlink&quot; title=&quot;IPFS介绍&quot;&gt;&lt;/a&gt;IPFS介绍&lt;/h2&gt;&lt;h3 id=&quot;IPFS尝试解决HTTP目前存在的四个问题：&quot;&gt;&lt;a href=&quot;#IPFS尝试解决HTTP目前存在的四个问题：&quot; class=&quot;headerlink&quot; title=&quot;IPFS尝试解决HTTP目前存在的四个问题：&quot;&gt;&lt;/a&gt;IPFS尝试解决HTTP目前存在的四个问题：&lt;/h3&gt;&lt;p&gt;. 服务低效，成本高。这也是大部分P2P服务比中心化服务器优秀的地方。&lt;/p&gt;
&lt;p&gt;. 网络服务受限于供应商，文件具有无法永久保存的风险，更无法历史回溯。&lt;/p&gt;
&lt;p&gt;. 中心化的网络权力过于集中，网络控制和监管某些程度上限制了科技创新。&lt;/p&gt;
&lt;p&gt;. 互联网服务大多依赖于骨干网络，一旦宕机大部分服务将无法使用。&lt;/p&gt;
&lt;h3 id=&quot;IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。&quot;&gt;&lt;a href=&quot;#IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。&quot; class=&quot;headerlink&quot; title=&quot;IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。&quot;&gt;&lt;/a&gt;IPFS的野心是取代现在的HTTP，去创建一个全新的去中心化网络。&lt;/h3&gt;
    
    </summary>
    
      <category term="Web" scheme="http://yqsailor.github.io/categories/Web/"/>
    
    
      <category term="IPFS" scheme="http://yqsailor.github.io/tags/IPFS/"/>
    
      <category term="Web" scheme="http://yqsailor.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Next 搭建个人博客</title>
    <link href="http://yqsailor.github.io/2018/09/12/hexo/"/>
    <id>http://yqsailor.github.io/2018/09/12/hexo/</id>
    <published>2018-09-12T02:02:31.000Z</published>
    <updated>2019-06-20T09:36:00.258Z</updated>
    
    <content type="html"><![CDATA[<p>突然有了写博客的想法，今天就研究了下如何搭建自己的博客，之后看到了比较流行的组合为Hexo + Next + Git pages，于事就一步步搭建了自己的博客，中间也踩了很多坑，因此想把这个经过记录下来，希望能帮到一些想搭建自己的博客的同志们。</p><h1 id="为什么选择Hexo"><a href="#为什么选择Hexo" class="headerlink" title="为什么选择Hexo"></a>为什么选择Hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的静态站点生成框架，它基于 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> 。 它有以下特点：</p><ul><li><i class="fa fa-bolt"></i><h6 style="display: inline;">　超快速度</h6><br><i>Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。</i></li><li><i class="fa fa-pencil"></i><h6 style="display: inline;">　支持Markdown</h6><br><i>Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。</i></li><li><i class="fa fa-cloud-upload"></i><h6 style="display: inline;">　一键部署</h6><br><i>只需一条指令即可部署到Github Pages，或其他网站</i></li><li><i class="fa fa-cog"></i><h6 style="display: inline;">　丰富的插件</h6><br><i>Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。</i></li></ul><p>通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 <a href="https://hexo.io/zh-cn/docs/tag-plugins.html" target="_blank" rel="noopener">标签插件</a> 来快速的插入特定形式的内容。</p><p>基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题</a>。<br><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 因其 <span id="yu-1">精于心，简于形</span> 的风格，一直被广大用户所喜爱。</p><a id="more"></a><h1 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h1><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装:</p><blockquote><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br><a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p></blockquote><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Mac：一般情况下自带git无需安装，如未安装使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>，<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a> 或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a> 安装</li><li>Windows：下载安装 git 。<a id="download" href="https://git-scm.com/download/win" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span></a></li></ul><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。（nvm：Node Version Manager）</p><h3 id="Mac-下安装-nvm"><a href="#Mac-下安装-nvm" class="headerlink" title="Mac 下安装 nvm"></a>Mac 下安装 nvm</h3><p>1、执行如下命令，需要先安装Git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/creationix/nvm.git .nvm</span><br></pre></td></tr></table></figure></p><p>2、将以下代码添加到 <code>~/.bashrc</code>, <code>~/.profile</code>, 或者 <code>~/.zshrc</code> 文件中，然后执行命令<code>source ~/.bashrc</code>重启配置信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$HOME</span>/.nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="comment"># This loads nvm</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/bash_completion"</span>  <span class="comment"># This loads nvm bash_completion</span></span><br></pre></td></tr></table></figure></p><h3 id="Windows-下安装-nvm"><a href="#Windows-下安装-nvm" class="headerlink" title="Windows 下安装 nvm"></a>Windows 下安装 nvm</h3><p>首先需要下载安装<a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a>，<a id="download" href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span><br></a></p><p>安装完nvm以后，我们可以打开命令行中执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nvm</span><br><span class="line">$ nvm install latest</span><br></pre></td></tr></table></figure></p><p>执行完以后，重启命令行，执行命令 <code>node -v</code> ，如果出现版本号，那么 <code>Node.js</code> 就安装成功了。<br><div class="note warning"><p> 如果没有安装成功，那可能就是墙的原因。建议下载 <code>Node.js</code> 直接安装。 <a id="download" href="https://nodejs.org/en/download/" target="_blank" rel="noopener"><i class="fa fa-download"></i><span> Download Now</span><br></a></p></div></p><h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><p>有了 Node.js ，我们可以使用 npm 安装 Hexo。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>安装 Hexo 完成后，我们首先需要为我们的项目创建一个<span id="inline-green">指定文件夹</span>（例如我创建了一个文件夹blog 。<code>/Users/yq/blog</code> ），在指定文件夹中执行下列命令， Hexo 将会在指定文件夹中新建所需要的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p><p>等待安装，安装完成后，<span id="inline-green">指定文件夹</span> 的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└──</span><br></pre></td></tr></table></figure></p><p>我们继续执行命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure></p><p>Hexo 将 source 文件夹中除 _posts 文件夹之外，开头命名为 _(下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。<br>这个时候，我们在浏览器中访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，就可以看到基于 Hexo 的默认主题的原型：<br><img src="/2018/09/12/hexo/images/hexo-default-theme.png" title="Hexo default theme"></p><h1 id="安装-NexT-主题"><a href="#安装-NexT-主题" class="headerlink" title="安装 NexT 主题"></a>安装 NexT 主题</h1><h2 id="1、下载-NexT-主题"><a href="#1、下载-NexT-主题" class="headerlink" title="1、下载 NexT 主题"></a>1、下载 NexT 主题</h2><p>依旧是在当前目录下，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>等待下载完成。<br><div class="note warning"><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml 。其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br>  我们将前者称为 <strong>站点配置文件</strong>，后者称为 <strong>主题配置文件</strong></p></div></p><h2 id="2、启用-NexT-主题"><a href="#2、启用-NexT-主题" class="headerlink" title="2、启用 NexT 主题"></a>2、启用 NexT 主题</h2><p>打开 <strong>站点配置文件</strong> ，找到 theme 字段，并将其值更改为 next 。<br>到此， NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前，我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h2 id="3、验证主题"><a href="#3、验证主题" class="headerlink" title="3、验证主题"></a>3、验证主题</h2><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。在服务启动的过程，注意观察命令行输出是否有任何异常信息。当命令行输出中提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，检查站点是否正确运行。</p><div class="note success"><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse</p></div><img src="/2018/09/12/hexo/images/hexo-next-theme.png" title="NexT Muse theme">现在，我们已经成功安装并启用了 NexT 主题。<div class="note primary"><p>关于更多基本操作和基础知识，请查阅 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 与 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a> 官方文档.</p></div><h1 id="Local-Search-配置"><a href="#Local-Search-配置" class="headerlink" title="Local Search 配置"></a>Local Search 配置</h1><p>添加百度/谷歌/本地 自定义站点内容搜索</p><ol><li><p>安装 <code>hexo-generator-searchdb</code>，在站点的根目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>编辑 站点配置文件，新增以下内容到任意位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li><li><p>编辑 主题配置文件，启用本地搜索功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></li></ol><h1 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h1><div class="note warning"><p>注意： baidu_analytics 不是你的百度 id 或者 百度统计 id</p></div><ol><li><p>登录 <a href="https://tongji.baidu.com" target="_blank" rel="noopener">百度统计</a>，定位到站点的代码获取页面</p></li><li><p>复制 hm.js? 后面那串统计脚本 id，如下图所示：</p></li></ol><img src="/2018/09/12/hexo/images/baidu_analytics.png"><ol start="3"><li>编辑<span class="label label-info">主题配置文件</span>， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。</li></ol><h1 id="右上角添加GitHub彩带和GitHub-Corner"><a href="#右上角添加GitHub彩带和GitHub-Corner" class="headerlink" title="右上角添加GitHub彩带和GitHub Corner"></a>右上角添加GitHub彩带和GitHub Corner</h1><p>提供两个获取样式的站点，<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">GitHub Ribbons</a>和<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a></p><p>考虑到适配移动端适配，重叠于菜单按钮，我取的是 GitHub Corners 的右上角的样式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改 https://your-url 、fill:#151513; 和 color:#fff;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://your-url"</span> <span class="attr">class</span>=<span class="string">"github-corner"</span> <span class="attr">aria-label</span>=<span class="string">"View source on GitHub"</span>&gt;</span><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px;"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>粘贴样式代码至<code>themes\next\layout\_layout.swig</code>文件中<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>下</p><h1 id="发布到GitHub"><a href="#发布到GitHub" class="headerlink" title="发布到GitHub"></a>发布到GitHub</h1><h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>Github Pages分为两类，用户或组织主页，项目主页。</p><p>创建用户或组织主页，只需创建一个名称为{yourusername}.github.io的新仓库即可。这边的yourusername填写自己的用户名。Github会识别并自动将该仓库设为Github Pages。用户主页是唯一的，填其他名称只会被当成普通项目。<br>创建项目主页。先新建一个仓库，名称随意，或是使用原有的仓库都可以。在项目主页 -&gt; Settings -&gt; Options -&gt; Github Pages中，将Source选项置为master branch(<em>如果无法设置就先选择一个主题</em>)，然后Save，这个项目就变成一个Github Pages项目了。</p><img src="/2018/09/12/hexo/images/git-pages-setting.png"><h2 id="安装deploy插件"><a href="#安装deploy插件" class="headerlink" title="安装deploy插件"></a>安装deploy插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="配置发布信息"><a href="#配置发布信息" class="headerlink" title="配置发布信息"></a>配置发布信息</h2><p>修改主题配置文件中的仓库信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;repository url&gt;  <span class="comment"># 仓库地址，例如我的是https://github.com/yqsailor/yqsailor.github.io</span></span><br><span class="line">  branch: [branch] <span class="comment"># 仓库分支，一般为master</span></span><br><span class="line">  message: [message]  <span class="comment"># git提交注释，此项可留空</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="本地调试步骤"><a href="#本地调试步骤" class="headerlink" title="本地调试步骤"></a>本地调试步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s --debug</span><br></pre></td></tr></table></figure></p><p>这种带 debug 的运行，如果出现错误，可以在命令行中看到错误提示信息。</p><h2 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h2><p>三部曲：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>当然在部署之前，需要先配置好配置文件中的 deploy。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"postName"</span>  <span class="comment">#新建文章</span></span><br><span class="line">$ hexo new page <span class="string">"pageName"</span> <span class="comment"># 新建页面</span></span><br><span class="line">$ hexo generate <span class="comment"># 生成静态页面至public目录</span></span><br><span class="line">$ hexo server <span class="comment"># 开启预览访问端口(默认端口4000，'ctrl+c'关闭server)</span></span><br><span class="line">$ hexo deploy <span class="comment"># 项目部署</span></span><br><span class="line">$ hexo <span class="built_in">help</span> <span class="comment"># 查看帮助</span></span><br><span class="line">$ hexo version <span class="comment"># 查看Hexo的版本</span></span><br></pre></td></tr></table></figure><h2 id="简写命令"><a href="#简写命令" class="headerlink" title="简写命令"></a>简写命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new == hexo n</span><br><span class="line">$ hexo generate == hexo g</span><br><span class="line">$ hexo server == hexo s</span><br><span class="line">$ hexo deploy == hexo d</span><br></pre></td></tr></table></figure><h2 id="常见问题1"><a href="#常见问题1" class="headerlink" title="常见问题1"></a>常见问题1</h2><p>在 hexo 的配置和设置文件中，在冒号后面没留空格会导致出问题：<br>正确的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">author: yq</span><br><span class="line">email: yqsailor@gmail.com</span><br><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure></p><h2 id="常见问题2"><a href="#常见问题2" class="headerlink" title="常见问题2"></a>常见问题2</h2><p>关于 Git 提交中用户名和 Email 的设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your name&quot;</span><br><span class="line">git config --global user.email &quot;Your email&quot;</span><br></pre></td></tr></table></figure></p><h2 id="常见问题3"><a href="#常见问题3" class="headerlink" title="常见问题3"></a>常见问题3</h2><p>Hexo 中的图标使用的是 <a href="http://fontawesome.io/" target="_blank" rel="noopener">Font Awesome</a> ，所以，我们的博客已经自带了 Font Awesome 中的所有图标，基本可以满足我们的所有需求，我们可以去 Font Awesome 中查找我们想要使用的图标。<br><i class="fa fa-github"></i> <code>&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-lg"></i> <code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-2x"></i> <code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></p><h2 id="常见问题4"><a href="#常见问题4" class="headerlink" title="常见问题4"></a>常见问题4</h2><p>Hexo 中使用markdown语法的绝对图片路径在首页无法展示，可改用标签插件语法：<br>配置_config.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure></p><p>将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</p><p>图片<em>_posts/post_name/image.jpg</em>,可通过如下方式访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br></pre></td></tr></table></figure></p><p></p><h5 style="color:#f63;"><i>最后要说的是：</i></h5><p></p><p id="div-border-top-green"><i><a href="https://github.com/yqsailor/blog" target="_blank" rel="noopener">博客源码</a> ， 欢迎 star<br></i></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然有了写博客的想法，今天就研究了下如何搭建自己的博客，之后看到了比较流行的组合为Hexo + Next + Git pages，于事就一步步搭建了自己的博客，中间也踩了很多坑，因此想把这个经过记录下来，希望能帮到一些想搭建自己的博客的同志们。&lt;/p&gt;
&lt;h1 id=&quot;为什么选择Hexo&quot;&gt;&lt;a href=&quot;#为什么选择Hexo&quot; class=&quot;headerlink&quot; title=&quot;为什么选择Hexo&quot;&gt;&lt;/a&gt;为什么选择Hexo&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的静态站点生成框架，它基于 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Node.js&lt;/a&gt; 。 它有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-bolt&quot;&gt;&lt;/i&gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　超快速度&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　支持Markdown&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　一键部署&lt;/h6&gt;&lt;br&gt;&lt;i&gt;只需一条指令即可部署到Github Pages，或其他网站&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt;&lt;h6 style=&quot;display: inline;&quot;&gt;　丰富的插件&lt;/h6&gt;&lt;br&gt;&lt;i&gt;Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。&lt;/i&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 &lt;a href=&quot;https://hexo.io/zh-cn/docs/tag-plugins.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;标签插件&lt;/a&gt; 来快速的插入特定形式的内容。&lt;/p&gt;
&lt;p&gt;基于 Hexo 这个优秀的博客框架，很多优秀的开发者奉献出了它们基于 Hexo 开发的&lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;主题&lt;/a&gt;。&lt;br&gt;&lt;a href=&quot;http://theme-next.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NexT&lt;/a&gt; 因其 &lt;span id=&quot;yu-1&quot;&gt;精于心，简于形&lt;/span&gt; 的风格，一直被广大用户所喜爱。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yqsailor.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yqsailor.github.io/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yqsailor.github.io/tags/Next/"/>
    
  </entry>
  
</feed>
